1. Тестирование и STLC. Принципы тестирования
2. Виды тестирования
3. QA, QC и тестирование. Верификация и валидация 
4. SDLC. Модели разработки ПО
5. Виды тестовой документации. Тест-кейс vs Чек-лист
6. Требования. Матрица трассируемости
7. Отчет о дефекте. Severity и Priority. ЖЦ дефекта
8. Техники тест-дизайна
9. Виды отчетов 
10. Эвристики
11. Интерфейс и его виды
12. Аутентификация и авторизация
13. ip-адреса. Идентификация ресурсов в сети. DNS
14. Клиент - серверная архитектура. Тонкий и тостый клиент
15. Эталонные модели OSI и TCP/IP. Виды сетевых протоколов
16. HTTP-протокол. Методы HTTP
17. Socket, WebSocket, AJAX
18. Веб-сервисы
19. Кэш и куки
20. Логи и его типы, уровни
21. Коды ответов сервера
22. Типы мобильных приложений. Симуляторы и эмуляторы
23. Основные проверки при тестировании мобильного приложения
24. Гайдлайны (11 примеров). Особенности мобильного тестирование
25. Основы HTML и CSS
26. HTML DOM

## 1. Тестирование и STLC. Принципы тестирования

Тестирование ПО (software testing) – процесс анализа программного средства и сопутствующей документации с целью выявления дефектов и повышению качества продукта.

Жизненный цикл тестирования ПО (Software Testing Lifecycle) - это последовательность действий, проводимых в процессе тестирования, с помощью которых гарантируется качество программного обеспечения и его соответствие требованиям.

Фазы STLC:
1.	Анализ требований (Requirement Analysis): один из важнейших этапов, потому что именно на нем можно почти бесплатно исправить недостатки проекта;
2.	Планирование тестирования (Test Planning): на этом этапе формируется план тестирования, т.е. мы определяем действия и ресурсы, которые помогут достичь целей тестирования;
3.	Разработка тест-кейсов (Test Case Development): выявление всех возможных случаев использования продукта, его характеристик и особенностей в процессе эксплуатации;
4.	Настройка тестовой среды (Test Environment Setup): настраиваются операционные системы и виртуальные машины, инструменты тестирования, также обращаемся с запросами к DevOps и администраторам, если требуется поддержка;
5.	Выполнение тестов (Test Execution): тесты выполняются на основе готовой тестовой документации и правильно настроенной тестовой среды;
6.	Завершение цикла испытаний (Test Cycle Closure): окончательная генерация отчетов о тестировании для клиента.

Принципы тестирования:
1.	Тестирование показывает наличие дефектов (Testing shows presence of defects) - Тестирование может показать, что дефекты присутствуют, но не может доказать, что дефектов больше нет;
2.	Исчерпывающее тестирование невозможно (Exhaustive testing is not possible) - Для проведения исчерпывающего тестирования придется протестировать все возможные входные значения и все пути выполнения программы, в большинстве случаев число таких вариаций стремится к бесконечности или просто на порядки превосходит отведенное время и бюджет;
3.	Раннее тестирование (Early testing) - Тестовые активности должны начинаться как можно раньше в SDLC, а именно когда сформированы требования;
4.	Скопление дефектов (Defect clustering) - Это может происходить потому, что определенная область кода особенно сложна и запутана, или потому, что внесение изменений производит «эффект домино»;
5.	Парадокс пестицида (Pesticide paradox) - Это эффект, при котором при регулярном прогоне тестовых сценариев ошибки перестают находиться;
6.	Тестирование зависит от контекста (Testing is context dependent) - Тестирование проводится по-разному в зависимости от контекста. Например, программное обеспечение, в котором критически важна безопасность, тестируется иначе, чем новостной портал;
7.	Заблуждение об отсутствии ошибок (Absence of errors fallacy) - Отсутствие найденных дефектов при тестировании не всегда означает готовность продукта к релизу. Система должна быть удобна пользователю в использовании и удовлетворять его ожиданиям и потребностям.

## 2. Виды тестирования

По объекту тестирования:
1.	Функциональное тестирование (functional testing) – проверка того что продукт обладает всем функционалом, который описан в требованиях;
2.	Нефункциональное тестирование (Non-Functional testing) - тестирование свойств, которые не относятся к функциональности системы:
  - Инсталляционное (installation testing) – установка, обновление, удаление;
  - Конфигурационное тестирование (configuration testing) – проверку работы ПО при различных конфигурациях системы (ОС, устройства, версиях браузеров);
  - Тестирование совместимости (compatibility testing) – проверка работы приложения на разных окружениях (кроссбраузерное и кроссплатформенное тестирование);
  - Тестирование удобства использования (usability testing) – тестирование направлено на удобство и понятность работы с приложением;
  - (i18n) Тестирование интернационализации (internationalization testing) – тестирование перевода на разные языки;
  - (l10n) Тестирование локализации (localization testing) – процесс адаптации нашего продукта к языку и культуре, формат даты и времени, правовые особенности, раскладка клавиатуры, контроль символики и цветов клиента;
  - Тестирование безопасности (security testing) – тестируем защищённость нашего программного продукта;
  - Тестирование интерфейса (interface testing) - проверки того, соответствует ли пользовательский интерфейс ПО требованиям;
  - Тестирование доступности (accessibility testing) – тестирование для людей с ограниченными возможностями, также для тех кто ограничен в своих возможностях (к примеру в момент когда человек за рулем);
  - Тестирование производительности (performance testing) – определяет работу вычислительной системы под определённой нагрузкой:
    - Нагрузочное тестирование (load testing) - проверяет способность приложения работать при ожидаемой рабочей нагрузке;
    - Стресс (stress) – проверяем что происходит с продуктом при высоких нагрузках;
    - Стабильность (stability) – тестируем работу сайта с определенными нагрузками в течении определённого времени;
    - Объемное (Volume testing) – проверка на передачу больших объемов информации;
    - Тестирование на отказ и восстановление (failover and recovery testing) – проверка на восстановление после ошибок и сбоев.

Тестирование, связанное с изменениями:
1.	Дымовое тестирование (smoke test) – проверка самого важного функционала продукта;
2.	Регрессионное тестирование (regression testing) –проверка того, что не нарушилась работоспособность работающей ранее функциональности, если её код мог быть затронут при использовании некоторых дефектов в другой функциональности;
3.	Тестирование сборки (build verification test) – тестирование на соответствие критериям качества новой сборки;
4.	Санитарное тестирование (sanity test) – это тестирование отдельной функциональности.

По исполнению сценария:
1.	Исследовательское тестирование (exploratory testing) – одновременно изучение проекта, функционала, проектирование тест кейсов в уме и тут же их исполнение не записывая и не создавая тестовую документацию;
2.	Свободное тестирование (ad-hoc testing) – импровизация без документации;
3.	Сценарное тестирование (scenario testing) – тестирование по заранее задокументированному сценарию.

По степени важности:
1.	Дымовой тест (smoke test) – проверка самого важного функционала продукта;
2.	Тест критического пути (critical path test) – проверяются типичные задачи продукта;
3.	Расширенный тест (extended test) – всё оставшееся что не проверяли в smoke и critical.

По цели тестирования:
1.	Тестирование новой функциональности (new feature test) – тестирование новой функциональности, которая ранее не тестировалась;
2.	Регрессионное тестирование (regression testing) – проверка того, что не нарушилась работоспособность работающей ранее функциональности, если её код мог быть затронут при исправлении некоторых дефектов в другой функциональности;
3.	Подтверждающее тестирование (re-test) - тестирование, с целью подтвердить успешность исправлений дефекта.

По направлению тестирования (По запуску кода):
1.	Статическое тестирование (static testing) (без запуска программы) – тестирование документации, дизайн. Если опытный программист, то глазами посмотреть код;
2.	Динамическое тестирование (dynamic testing) (с запуском программы).

По методу тестирования:
1.	Метод белого ящика (white box testing) - тестировщик имеет доступ к коду (unit test – это тестирование отдельного участка кода);
2.	Метод черного ящика (black box testing) - тестировщик не имеет доступа к коду (GUI);
3.	Метод серого ящика (grey box testing) - к части кода доступ есть, а к части нет (UI, dev tools, Postman).

По уровню тестирования:
1.	Компонентное (component testing) – это тестирование отдельного модуля (обычно unit test делает разработчик);
2.	Интеграционное (integration testing) - проверка взаимодействия модулей;
3.	Системное (system testing) - полная проверка приложения;
4.	Приемочное (acceptance testing) - вид тестирование на этапе сдачи готового продукта или его части.

По позитивности:
1.	Позитивное (positive testing) - тестирование которое соответствует нормальному поведению системы;
2.	Негативное (negative testing) - применяются сценарии которые соответствуют нештатному поведению системы.

По степени автоматизации:
1.	Ручное (manual testing) – тестировщики выполняют тесты не используя средств автоматизации;
2.	Автоматизированное (automated testing) – с использованием ПО.

По исполнителю тестирования:
1.	альфа-тестирование (alpha testing) - проверка программного продукта на поздней стадии, разработчиками;
2.	бета-тестирование (beta testing) - оценка ПО перед выходом на рынок в фокус-группе или добровольцами.

## 3. QA, QC и тестирование. Верификация и валидация 

Три уровня работы с качеством программного обеспечения:

- Специалист по тестированию занимается выполнением тестов. Тестированием называют проверку соответствия результатов работы программного продукта на соответствие заданным критериям. Тестировщики занимаются тестированием всего продукта в целом или же отдельных компонентов. 

- QC (Quality Control) — контроль качества продукта. Задача QC-специалиста — проверка конкретного продукта, что включает анализ кода продукта, дизайна, плюс тестирование. QC-инженер разрабатывает стратегию тестирование вполне определенного тестирования, взаимодействует с разработчиками и организует само тестирование.

- QA (Quality Assurance) — обеспечение качества продукта. QA-специалист контролирует и обеспечивает качество работы продукта компании. Он отвечает и за отдельные этапы разработки софта. В частности, за выбор инструментов для разработки, предотвращение возможных проблем. Еще он участвует в процессе совершенствования продукта. QA охватывает все этапы разработки, включая описание проекта, собственно, тестирование, релиз и, зачастую, пост-релизный этап.

Верификация - это проверки, выполняемые в процессе разработки ПО для ответа на вопрос: “правильно ли мы разрабатываем продукт? (Верификация всегда происходит до валидации)

Валидация - это процесс оценки конечного продукта, чтобы проверить, соответствует ли он потребностям бизнеса и ожиданиям клиентов, т.е. отвечает на вопрос: “правильный ли мы разработали продукт?”

Понять, что тестировщик выполнил свою работу хорошо можно по факту выполнения следующих задач:
- продукт проверен на соответствие требованиям;
- сведено к минимуму количество дефектов, которые обнаружит конечный пользователь;
- предоставлена отчетность по актуальному качеству продукта и любых остаточных рисках заинтересованным лицам.

## 4. SDLC. Модели разработки ПО
Жизненный цикл ПО (Software Development Life Cycle) – это период времени который начинается когда принимаются решение о том что нам надо сделать ПО и заканчивается выводом его из эксплуатации.

Идея → Сбор и анализ требований (сбор требований к разрабатываемому программному обеспечению; их систематизацию; документирование; анализ; выявление и разрешение противоречий) → Архитектура и дизайн (программисты и системные архитекторы, руководствуясь требованиями, разрабатывают высокоуровневый дизайн системы) → Разработка и тестирование (разработка алгоритмов – создание логики работы программы; написание исходного кода; компиляция – преобразование в машинный код; тестирование и отладка – юнит-тестирование) → Релиз (когда продукт доступен конечному пользователю) → поддержка (чинятся баги и дописываются новые идеи, чтобы каждый пользователь был счастлив) → вывод из эксплуатации.

МОДЕЛИ РАЗРАБОТКИ ПО:

- Водопадная (waterfall) – суть заключается в том, что мы можем переходить к следующему шагу разработки или тестирования только после того, как предыдущий был успешно завершён. Данная модель разработки подходит для проектов с чётко определёнными требованиями и для которых не предусматривается их изменение в процессе разработки (банковские структуры, медицинские, военные и космические отрасли).
К недостаткам водопадной модели принято относить тот факт, что участие пользователей ПО в ней либо не предусмотрено вообще, либо предусмотрено лишь косвенно на стадии однократного сбора требований. С точки зрения же тестирования эта модель плоха тем, что тестирование в явном виде появляется здесь лишь с середины развития проекта, достигая своего максимума в самом конце.
____
- V-модель –  это усовершенствованная каскадная модель, в которой заказчик с командой программистов одновременно составляют требования к системе и описывают, как будут тестировать её на каждом этапе. Тестирование здесь появляется уже на самых ранних стадиях развития проекта, что позволяет минимизировать риски, а также обнаружить и устранить множество потенциальных проблем до того, как они станут проблемами реальными.
Данная модель обычно используется в проектах где есть временные и финансовые ограничения и для таких задач, которые предполагают более широкое тестовое покрытие.
____
- Итерационная инкрементальная модель (Iterative and incremental model) – Итерационная инкрементальная модель особенностью данной модели является разбиение проекта на относительно небольшие промежутки (итерации), каждый из которых в общем случае может включать в себя все классические стадии. Итогом итерации является улучшение продукта - инкремент, выраженное в промежуточном билде (build).
Длина итераций может меняться в зависимости от множества факторов, однако сам принцип многократного повторения позволяет гарантировать, что и тестирование, и демонстрация продукта конечному заказчику (с получением обратной связи) будет активно применяться с самого начала и на протяжении всего времени разработки проекта. Во многих случаях допускается распараллеливание отдельных стадий внутри итерации и активная доработка с целью устранения недостатков, обнаруженных на любой из (предыдущих) стадий. Итерационная инкрементальная модель очень хорошо зарекомендовала себя на объемных и сложных проектах, выполняемых большими командами на протяжении длительных сроков. Однако к основным недостаткам этой модели часто относят высокие накладные расходы, вызванные высокой «бюрократизированностью» и общей громоздкостью модели.
____
- Спиральная модель (spiral model) - Используя эту модель, заказчик и команда разработчиков серьёзно анализируют риски проекта и выполняют его итерациями. Последующая стадия основывается на предыдущей, а в конце каждого витка — цикла итераций — принимается решение, продолжать ли проект.
Спиральная модель похожа на инкрементную, но здесь гораздо больше времени уделяется оценке рисков. С каждым новым витком спирали процесс усложняется. Эта модель часто используется в исследовательских проектах и там, где высоки риски. Эта модель не подойдет для малых проектов, она для сложных и дорогих, например, таких, как разработка системы документооборота для банка, когда каждый следующий шаг требует большего анализа для оценки последствий, чем программирование.
____
- Agile – это набор методов и принципов гибким управлением проектами. То как мы должны мыслить, какие должны быть ценности, чтобы правильно построить процессы.
Ценности Agile:
1. Люди и взаимодействия важнее процессов и инструментов;
2. Работающий продукт важнее исчерпывающей документации;
3. Сотрудничество с клиентом важнее условий согласования контракта;
4. Готовность к изменению важнее следования первоначального плана.
Методология подходит для больших или нацеленных на длительный жизненный цикл проектов, постоянно адаптируемых к условиям рынка. 
Основополагающие принципы Agile Manifesto:
1. наивысшим приоритетом признается удовлетворение заказчика за счёт ранней и бесперебойной поставки ценного программного обеспечения;
2. изменение требований приветствуется даже в конце разработки (это может повысить конкурентоспособность полученного продукта);
3. частая поставка работающего программного обеспечения (каждые пару недель или пару месяцев с предпочтением меньшего периода);
4. общение представителей бизнеса с разработчиками должно быть ежедневным на протяжении всего проекта;
5. проекты следует строить вокруг заинтересованных людей, которых следует обеспечить нужными условиями работы, поддержкой и доверием;
6. самый эффективный метод обмена информацией в команде — личная встреча;
7. работающее программное обеспечение — лучший измеритель прогресса;
8. спонсоры, разработчики и пользователи должны иметь возможность поддерживать постоянный темп на неопределённый срок;
9. постоянное внимание к техническому совершенству и хорошему проектированию увеличивают гибкость;
10. простота как искусство не делать лишней работы очень важна;
11. лучшие требования, архитектура и проектные решения получаются у самоорганизующихся команд;
12. команда регулярно обдумывает способы повышения своей эффективности и соответственно корректирует рабочий процесс.
Наиболее удачным примером использования Гибкой модели (Agile-model) на сегодняшний день является фреймворк Scrum.
____
- Scrum – это фреймворк для управления проектами. Вся разработка делится на спринты. Вся работа разбивается на итерации, которые называются Спринт (Sprint). Каждый Спринт длиться от 2х до 4х недель.
РОЛИ В SCRIM: 
Development team – это команда работающих над проектом разработчики, тестировщики, бизнес-аналитики. Действет коллективная ответственность; 
Scrum-мастер – человек, который следит, чтобы соблюдались принципы скрама, обучение нового персонала. (не участвует в разработке) Этот человек не руководитель команды, а тренер; 
Product owner – представляет интересы бизнеса, общается непосредственно с заказчиком, выясняет что необходимо и передает эту информацию. представляет клиента, не руководитель команды.
СОБЫТИЯ В SCRUM: 
1. Планирование спринта (Sprint Planning) - это событие в Scrum, которое знаменует начало спринта. В ходе планирования определяется объём работы на спринт и способы выполнения этой работы;
2. Ежедневный Scrum (Daily Scrum) – Что ты делал вчера? Что ты будешь делать сегодня? Какие есть препятствия для выполнения цели?
3. Обзор спринта (Sprint Review) – подводим итоги того что было у нас сделано во время нашего спринта;
4. Ретроспектива (Sprint Retrospective) - проводится в конце спринта. Её суть – выяснить, что можно улучшить исходя из результатов нашей итерации.
АРТЕФАКТЫ В SCRUM:
1. Бэклог продукта (Product Backlog) – это список в котором все задачи для реализации готового продукта;
2. Уточнение бэклога продукта (Product Backlog Refinement) – собирается команда и product owner который представляет вам новый юзер стори который он написал (уточняет интересующие вопросы);
3. Критерии подготовленности (Definition of Ready) – DoR (фокус на уровне бэклога) – помогает заказчику создать хорошо написанные пользовательские истории, которые готовы для разработки;
4. Пользовательские истории (User Stories) – это формулировка намерения, описывающая что-то, что система должна делать для пользователя. As a [Rose], I can [Functionality], So that [Rationale], Acceptance criteria.
5. Покер планирования (Planning poker) – это оценка юзер стори 
6. Бэклог спринта (Sprint Backlog) – выбираем что мы будем реализовывать в данном спринте, перетягиваем из бэклога продукта стори в бэклог спринта;
7. Инкремент продукта (Product Increment) – это всё то что мы разработали до и разработаем в конце данной итерации;
8. Критерии готовности (Definition of Done) – DoD (фокус на уровне спринта или релиза) – помогает проверить работу в соответствии со всеми требованиями проекта, а не только продемонстрировать, что функциональности работают.
МЕТРИКИ SCRUM:
1. Velocity – это скорость нашей команды. Рассчитывается как среднее арифметическое значение завершённых стори поинтов в предыдущих спринтах;
2.Capacity – количество доступного времени членов команды. Рассчитывается: все часы в итерации на каждого штатного разработчика нашей Development команды;
3. Диаграмма сгорания задач (Burndown chart)
4. Накопительная диаграмма потока (Cumulative flow diagram)
____
- Kanban – система, построенная на визуализации процесса выполнения задач команды. Основная идея в системе уменьшать количество задач, выполняемых в данный момент. Задача проходит по всем этапам на доске и как только она выполнена её можно отдавать заказчику. Kanban-доска состоит из колонок каждый из которых это отдельный процесс разработки. Пример: список задач которые нужно сделать, задачи в работе, выполненные задачи, задачи готовые к тестированию, задача протестирована.

## 5. Виды тестовой документации. Тест-кейс vs Чек-лист

Тестовая документация бывает двух видов внешняя и внутренняя:

Внешняя документация:
- Замечание – комментарий о небольшой неточности в реализации продукта;
- Баг-репорт – это технический документ, который содержит в себе полное описание бага;
- Запрос на изменение (улучшение) – описание требований, которые не были учтены при планировании/реализации продукта. И пути/рекомендации по модификации продукта;
- Отчет о тестировании (тест репорт) – документ, предоставляющий сведения о соответствии/ несоответствии продукта требованиям.

Внутренняя документация:
- Тест план (Test Plan) - это документ, описывающий весь объем работ по тестированию, начиная с описания объекта, стратегии, расписания, критериев начала и окончания тестирования, до необходимого в процессе работы оборудования, специальных знаний, а также оценки рисков с вариантами их разрешения.
(Хороший тест план отвечает на вопросы: Что тестируем? Где тестируем? Когда тестируем? Как тестируем?);
- Тестовый сценарий – последовательность действий над продуктом. Фактически при успешном прохождении всего тестового сценария мы можем сделать заключение о том, что продукт может выполнять ту или иную возложенную на него функцию;
- Тест набор (Test suite) -  набор тест-кейсов, собранных в группу для достижения некоторой цели. (Выполнения каждого являются некоторыми предусловиями для начала выполнения следующего. Тест кейсы идут по порядку);
- Чек-лист (check-list) – набор идей тестов;
- Тест кейс (test case) – набор входных данных, условий выполнения и ожидаемых результатов, разработанный с целью проверки того или иного св-ва или поведение программного средства.  

Атрибуты тест-кейса:
1. Уникальный идентификатор тест-кейса (необходим для удобной организации хранения и навигации по нашим тест-наборам).
2. Название (основная тема, или идея тест-кейса. Кратное описание его сути);
3. Предусловия (описание условий, которые не имеют прямого отношения к проверяемому функционалу, но должны быть выполнены. Например, оставить комментарий на вашем портале может только зарегистрированный пользователь. Значит для тест-кейса «Создание комментария» будет необходимо выполнение предусловия «пользователь зарегистрирован», и «пользователь авторизован»)
4. Шаги (описание последовательности действий, которая должна привести нас к ожидаемому результату);
5. Фактический результат;
6. Ожидаемый результат;
7. Дефект.

Преимущества: простота прохождения, удобство обучения;

Недостатки: долго писать, много копипасты, трудно поддерживать, долго писать.

Атрибуты чек-листа:
1. Версия билда;
2. Окружение;
3. Дата;
4. Автор;
5. Тип тестов;
6. Описание теста;
7. Результат теста.

Преимущества: мало текста, нет копипасты, проще поддерживать, быстрее писать.

Недостатки: малопонятны новичкам, возможное непонимание проверки (может быть непонятен замысел автора той или иной проверки).

## 6. Требования. Матрица трассируемости

Требования — это спецификация (описание) того, что должно быть реализовано.

Пользовательская история определяет требования к любой функциональности или фиче, в то время как критерии приемки (Acceptance Criteria) определяют критерии готовности (Definition of done) для пользовательской истории или требования.

Уровни требований:
1. Бизнес требования (Цель, ради которой создаётся продукт (для чего? Какая польза? Как получить прибыль?));
2. Пользовательские требования (задачи, которые пользователь может выполнять с помощью продукта);
3. Продуктные требования: 
  - Функциональные требования (охватывают предполагаемое поведение системы, определяя действия, которые система способна выполнять. Описывается в системной спецификации. В основном влияют на дизайн системы);
  - Нефункциональные требования (охватывают свойства системы (удобства использования, надежность, масштабируемость) которыми она должна обладать при реализации своего поведения)).

Пути выявления требований:
- Интервью (беседую с заказчиком или пользователями);
- Наблюдение (наблюдая за работой пользователя в похожем продукте или в старой версии и выяснить что их интересует и что нужно улучшить);
- Самостоятельное описание (мы можем самостоятельно написать требования включив здравый смысл);
- Прототипирование (т.е. разрабатывая сайт и у нас есть конкурент, мы можем зайти к нему и посмотреть, как он работает, как реализованы разные функции);

Свойства требований:
- Завершённость (требование должно содержать всю необходимую информацию);
- Непротиворечивость (одни требования не должны противоречить другим);
- Корректность (требование должно четко указывать на то, что должно выполнять приложение);
- Недвусмысленность (точность формулировки в требованиях может по-разному интерпретироваться тестировщиками, разработчиками и другими участниками проекта);
- Проверяемость (требование должно быть проверено на предмет того, выполняется оно или нет. Если мы что-то не можем проверить значит такое требование не нужно записывать);
- Модифицируемость (исправление / внесение правок в требования должно быть простой операцией.);
- Прослеживаемость (возможность отследить связь между требованием и другими артефактами проекта, каждое требование имеет уникальный идентификатор, по которому оно легко прослеживается).

Как упростить работу с требованиями:
- Написать тест-кейсы – когда мы получаем требования мы можем сразу написать тест-кейсы, если мы не можем написать его (мы не можем придумать проверки, которые покрыли бы это требование). В данном случае мы можем обратиться к нашему Product owner чтобы он связался с заказчиком, и они переформулировали это требование, узнали точно ли нужна эта функциональность. 
- Задавать вопросы – самое простое мы обращаемся к нашему аналитику или заказчику (если есть такая возможность) и задаём уточняющие вопросы.
- Нарисовать схему – интеллект-карты (мы берём большое требование и разбиваем его на маленькие функциональности, а их ещё на более мелкие), Use-cases (так называемые варианты использования, которые описывают все действия, которые наш пользователь может произвести и реакцию системы на эти действия).
- Рецензирование – когда кто-то пишет требования и мы выступаем рецензором этого требования.

Способы представления (как они могут выглядеть):
- Use-cases – это перечень действий, сценарий по которому пользователь взаимодействует с приложением, программой для выполнения какого-либо действия для достижения конкретной цели.
- User story - это короткая формулировка намерения, описывающая что-то, что система должна делать для пользователя.
- Ui mockup – требования могут выглядеть непосредственно как mockup, шаблоны нашего ui - которого мы видим на экране.
- Спецификации - документ, устанавливающий требования. 

Матрица трассируемости (Requirement Traceability Matrix AKA Traceability Matrix or Cross Reference Matrix) используется для документирования связей между требованиями и тест-кейсами по этим требованиям и наглядного отображения трассируемости в виде простой таблицы.

![image](https://user-images.githubusercontent.com/88891623/189289985-3990083b-9449-4ec2-8cb6-216587e6c7cd.png)

Матрица трассируемости может служить одновременно в качестве матрицы покрытия. Наличие такой матрицы позволяет объективно оценить, какая часть продукта покрыта тестами, а какая нет.

## 7. Отчет о дефекте. Severity и Priority. ЖЦ дефекта

Баг – это несоответствие фактического результата и ожидаемого.

Баг-репорт – это технический документ, который содержит в себе полное описание бага.
 
Атрибуты баг-репорта:
1. Id (уникальный номер);
2. Summary (оглавление, краткое описание);
3. Environment (окружение);
4. Preconditions (предварительные условия);
5. Step to reproduce (шаги для воспроизводства);
6. Expected result (ожидаемый результат);
7. Actual result (фактический результат);
8. Attachments (картинки, видео, логи – это текстовые файлы, в которых хранится информация о посещениях, параметрах посещений вашего сайта и ошибках, которые возникали на нем);
9. Priority (приоритет);
10. Severity (серьёзность);
11. Status (статус).
 
Серьёзность проблемы:
- Blocker — устанавливается, если баг блокирует дальнейшую работу приложения или процесс тестирования;
- Critical — присваивается при значительном влиянии проблемы на поведение ПО, но без блокировки его работы или процесса тестирования;
- Major — Весьма серьезная ошибка, свидетельствующая об отклонении от бизнес логики или нарушающая работу программы. Не имеет критического воздействия на приложение;
- Minor — Незначительный дефект, не нарушающий функционал тестируемого приложения, но который является несоответствием ожидаемому результату. Например, ошибка дизайна;
- Trivial – Баг, не имеющий влияние на функционал или работу программы, но который может быть обнаружен визуально. Например, ошибка в тексте.
 
Приоритет проблемы:
- High – исправить необходимо в первую очередь;
- Medium – требуется исправить, но не оказывает критическое воздействие на работу приложения;
- Low – исправить в последнюю очередь.
 
Жизненный цикл дефектов:
1. Новый (New). Тестировщик нашел баг, дефект успешно занесен в «Bug-tracking» систему;
2. Открыт (Opened). После того, как тестировщик отправил ошибку, она либо автоматически, либо вручную назначается на человека который должен её проанализировать (обычно Project Manager). В зависимости от решения менеджера проекта, баг может быть:
3. Отложен (Deferred). Исправление этого бага не несет ценности на данном этапе разработки или по другим, отсрочивающим его исправление причинам;
4. Отклонен (Rejected). По разным причинам дефект может и не считаться дефектом или считаться неактуальным дефектом, что вынуждает отклонить его;
5. Дубликат (Duplicate). Если описанная ошибка уже ранее была внесена в «Bug-tracking» систему, то статус такой ошибки меняется на «дубликат»;
6. Назначен (Assigned). Если ошибка актуальна и должна быть исправлена в следующей сборке (build), происходит назначение на разработчика который должен исправить ошибку;
7. Исправлен (Fixed). Ответственный за исправление бага разработчик заявляет, что устранил дефект. В зависимости от того, исправил ли разработчик дефект, дефект может быть:
8. Проверен (Verified). Тестировщик проверяет, действительно ли ответственный разработчик исправил дефект, или все-таки разработчик безответственный. Если бага больше нет, он получает данный статус;
9. Повторно открыт (Reopened). Если опасения тестировщика оправданы и баг в новом билде не исправлен – он все так же потребует исправления, поэтому заново открывается;
10. Закрытый (Closed). В результате определенного количества циклов баг все-таки окончательно устранен и больше не потребует внимания команды – он объявляется закрытым.

## 8. Техники тест-дизайна
 
Тест-дизайн – это этап процесса тестирования ПО, на котором проектируются и создаются тестовые случаи (тест-кейсы) в соответствии с определёнными ранее критериями качества и целями тестирования.
 
Тест-дизайнер должен выстроить процесс тестирования всех важнейших частей программного продукта, используя минимально возможное количество проверок.
 
Методики:
1. Тестирование Классами Эквивалентности (Equivalence Class Testing) - Тестовые данные разбиваются на определенные классы допустимых значений. В рамках каждого класса выполнение теста с любым значением тестовых данных приводит к эквивалентному результату. После определения классов необходимо выполнить хотя бы один тест в каждом классе.
____
2. Тестирование Граничных Значений (Boundary Value Testing) - Эта техника основана на том факте, что одним из самых слабых мест любого программного продукта является область граничных значений. Для начала выбираются диапазоны значений – как правило, это классы эквивалентности. Затем определяются границы диапазонов. На каждую из границ создается 3 тест-кейса: первый проверяет значение границы, второй – значение ниже границы, третий – значение выше границы.
____
3. Таблица Принятия Решений (Decision Table Testing) - способ компактного представления модели со сложной логикой; инструмент для упорядочения сложных бизнес требований, которые должны быть реализованы в продукте. Это взаимосвязь между множеством условий и действий.

В таблицах решений представлен набор условий, одновременное выполнение которых должно привести к определённому действию.
____
4. Тестирование Состояний и Переходов (State-Transition Testing) - Суть заключается в том что любая система находится в различных состояниях и определённые действия приводят к изменению этого состояния (Удобнее нарисовать и стрелками соединит там где должны быть переходы и где нельзя из одного состояния попасть в другое)
____
5. Метод Парного Тестирования (Pairwise testing) - Суть метода не в том, чтобы перебрать все возможные пары параметров, а в том, чтобы подобрать пары, обеспечивающие максимально эффективную проверку при минимальном количестве выполняемых тестов.
____
6. Доменный анализ (Domain Analysis Testing) - Это техника основана на разбиении диапазона возможных значений переменной (или переменных) на поддиапазоны (или домены), с последующим выбором одного или нескольких значений из каждого домена для тестирования. Во многом доменное тестирование пересекается с известными нам техниками разбиения на классы эквивалентности и анализа граничных значений. Но доменное тестирование не ограничивается перечисленными техниками. Оно включает в себя как анализ зависимостей между переменными, так и поиск тех значений переменных, которые несут в себе большой риск (не только на границах).
____
7. Сценарий использования (Use Case Testing) - Use Case описывает сценарий взаимодействия двух и более участников (как правило – пользователя и системы). Пользователем может выступать как человек, так и другая система. Для тестировщиков Use Case являются отличной базой для формирования тестовых сценариев (тест-кейсов), так как они описывают, в каком контексте должно производиться каждое действие пользователя. Use Case, по умолчанию, являются тестируемыми требованиями, так как в них всегда указана цель, которой нужно достигнуть, и шаги, которые надо для этого воспроизвести.

## 9. Виды отчетов 

Отчет (Reports) - это документ, содержащий информацию о выполненных действиях, результатах проведённой работы. Обычно он включает в себя таблицы, графики, списки, просто описывающую информацию в виде текста. Их пропорция и содержание определяют пользу и понятность отчета.

Наиболее известные варианты отчетов в тестировании:

1. Отчет по инциденту (incident report): Документ, описывающий событие, которое произошло, например, во время тестирования, и которое необходимо исследовать. (IEEE 829) 

Инцидент - это в основном любое неожиданное поведение или реакция программного обеспечения, требующая расследования.

Инцидент необходимо расследовать, и на основании расследования инцидент может быть преобразован в дефект. Чаще всего это оказывается дефектом, но иногда это может произойти из-за различных факторов, например:
- Человеческий фактор;
- Требование отсутствует или неясно;
- Проблема среды, например отсутствие ответа от внутреннего сервера, вызывающее периодическое непредвиденное поведение или ошибку. Либо неправильная конфигурация среды;
- Ошибочные тестовые данные;
- Некорректный ожидаемый результат.

Incident report призван зафиксировать и сообщить об инциденте заинтересованным лицам, провести расследование. Составляется аналогично баг-репорту, возможно с упором на расследование, обсуждение, влияние (impact) и может быть назначен не на разработчиков для уточнения деталей.

2. Отчет о результатах тестирования (test result report): периодический отчет, в котором документируется подробная информация о выполнении теста и его результате. Также он содержит условия, предположения, ограничения теста, какой элемент теста кем тестируется. Помимо этого вносится подробная информация об оставшейся работе, чтобы показать, сколько еще работы необходимо выполнить в проекте.

3. Отчет о выполнении теста (Test Execution Report): содержит детали выполнения и результат выполнения теста. Обычно его готовят для отправки вышестоящему руководству от группы тестирования, чтобы показать состояние выполнения теста и ход тестирования. Когда мы доставляем программное обеспечение клиенту, мы вкратце отправим полную информацию о выполнении теста. Это даст клиенту лучшее понимание выполненного теста и покрытия.

4. Отчет о ходе тестирования (test progress report): Документ, подводящий итог задачам и результатам, составляемый с определенной периодичностью с целью сравнения прогресса тестирования с базовой версией (например, с исходным планом тестирования) и извещения о рисках и альтернативах, требующих решения руководства. 

5. Аналитический отчет о тестировании (test evaluation report): Документ, создаваемый в конце процесса тестирования и подводящий итог тестовым активностям и результатам. Также в нем содержится оценка процесса тестирования и полученный опыт. 

6. Итоговый отчет о тестировании (test summary report): Документ, подводящий итог задачам и результатам тестирования, также содержащий оценку соответствующих объектов тестирования относительно критериев выхода. 

Сводный отчет о тестировании содержит подробную информацию о тестировании, проведенном на протяжении жизненного цикла разработки программного обеспечения. Элементы в итоговом отчете по тестированию различаются от организации к организации, а также различаются для разных проектов. Информация в отчете об испытаниях основывается на аудитории отчета об испытаниях. Аудитория может быть клиентом, менеджментом, бизнес-аналитиком, разработчиками, членами команды тестирования, членами организации и т. д.

7. Отчет о пользовательском приемочном тестировании (User acceptance test report): создается во время и после UAT. В нем указываются подробности проведенного пользователем приемочного теста и результат пользовательского приемочного теста. В нем также перечислены дефекты, не учтенные при UAT.

Приемочное пользовательское тестирование (UAT – User Acceptance Testing) – тестирование, которое проводится конечными пользователями системы с целью принятия решения о внедрении.

## 10. Эвристики

Эвристики – это быстрые, недорогие способы решения проблемы или принятия решения. Эвристики подвержены ошибкам, то есть они могут как сработать, так и не сработать. Также эвристики зависят от контекста.

1. Эвристика «Время вышло!». Для многих специалистов по тестированию это наиболее распространенная эвристика: мы останавливаем тестирование, когда заканчивается выделенное на него время.
2. Эвристика пиньяты (The Piñata Heuristic). Мы прекращаем ломать программу, когда начинают выпадать конфеты – мы останавливаем тестирование, когда видим первую достаточно серьезную проблему.
3. Эвристика «мертвой лошади» (The Dead Horse Heuristic). В программе слишком много ошибок, так что продолжение тестирования не имеет смысла. Мы знаем, что все изменится настолько, что сведет на нет результаты текущего тестирования.
4. Эвристика «Задание выполнено» (The Mission Accomplished Heuristic). Мы останавливаем тестирование, когда найдены ответы на все поставленные вопросы.
5. Эвристика «Отмена задания» (The Mission Revoked Heuristic). Наш клиент сказал нам: «пожалуйста, прекратите тестирование». Это может произойти по причине перерасхода бюджета, или вследствие отмены проекта, и по любой другой причине. Какова бы ни была причина, нам поручили остановить тестирование
6. Эвристика «Я зашел в тупик!» (The I Feel Stuck! Heuristic). По какой бы то ни было причине мы останавливаемся, поскольку обнаруживаем некое препятствие. У нас нет информации, которая нам требуется (например, многие люди заявляют, что не могут тестировать без достаточного количества спецификаций). Имеется блокирующая ошибка, и таким образом мы не можем перейти в ту область продукта, которую необходимо протестировать, у нас нет необходимого оборудования или инструментария, у команды нет квалификации, требуемой для выполнения некоторых специальных тестов.
7. Эвристика «освежающей паузы» (The Pause That Refreshes Heuristic). Вместо прекращения тестирования мы приостанавливаем его на некоторое время. Мы можем остановить тестирование и сделать перерыв, когда мы устали, когда нам стало скучно или пропало вдохновение. Мы можем сделать паузу на то, чтобы выполнить некоторые исследования, разработать планы, поразмыслить над тем, что мы делали в прошлом и понять, что делать дальше. Идея заключается в том, что нам требуется определенный перерыв, после которого мы сможем вернуться к продукту со свежим взглядом или свежими мыслями.Также есть и другой вид паузы: мы можем остановить тестирование какой-либо функции, поскольку в настоящий момент другая имеет более высокий приоритет.
8. Эвристика «Отсутствие продвижения» (The Flatline Heuristic). Что бы мы ни делали, мы получаем тот же самый результат. Это может происходить в случае, когда программа падает определенным способом или перестает отвечать, но также мы можем не продвигаться, когда программа в основном ведет себя стабильно: "выглядит хорошо!"
9. Эвристика Привычного завершения (The Customary Conclusion Heuristic). Мы останавливаем тестирование тогда, когда мы обычно останавливаем тестирование. Имеется протокол, задающий определенное количество идей для тестирования, или тест-кейсов, или циклов тестирования, или как вариант – имеется определенный объем работ по тестированию, который мы выполняем и после этого останавливаемся. Agile-команды, например, часто применяют такой подход: «когда выполнены все приемочные тесты, мы знаем, что продукт готов к поставке». Эвальд Руденриджс (Ewald Roodenrijs) приводит в своем блоге пример этой эвристики в статье «Когда прекращать тестирование». Он говорит, что он останавливается, «когда выполнено определенное количество тестовых циклов, включая регрессионное тестирование».
Отличие от эвристики «Время вышло!» в том, что временные ограничения могут изменяться более гибко, чем некоторые другие. Поскольку в большинстве проектов главенствует именно график проекта, и у меня и у Джеймса заняло некоторое время осознание того, что эта эвристика также очень распространена. Иногда мы можем слышать фразы типа «один тест на требование» или «один положительный и один отрицательный тест на требование», в качестве соглашения для определения «достаточно хорошего» тестирования. (Конечно же, мы не согласны с этим, но мы слышим это).
10. Больше нет интересных вопросов (No more interesting questions). В этот момент мы решаем, что не осталось вопросов, ответы на которые были бы достаточно ценными, чтобы оправдать стоимость продолжения тестирования, и поэтому мы останавливаемся. Эта эвристика используется в основном как дополнение к другим эвристикам, помогая принять решение о том, есть ли какие-то вопросы или риски, которые отменяют действие этих эвристик (примеры таких вопросов я привожу после каждой эвристики). Кроме того, если одна эвристика советует нам прекратить тестирование, следует проверить, нет ли интересных вопросов или серьезных рисков в других областях, и если они есть, то мы скорее продолжим тестирование, чем остановимся.
11. Эвристика уклонения/безразличия (The Avoidance/Indifference Heuristic). Иногда людей не интересует дополнительная информация, либо они не хотят знать, что происходит в программе. Тестируемое приложение может быть первой версией, которую, как мы знаем, скоро заменят. Некоторые люди прекращают тестирование по причине лени, злого умысла или отсутствия мотивации. Иногда бизнес-критичность выпуска нового релиза настолько высока, что никакая мыслимая проблема не остановит выход программы, и поэтому никакие новые результаты тестирования не будут иметь значения.

## 11. Интерфейс и его виды

Интерфейс — способ взаимодействия пользователя с программой или программы с программой.

Типы интерфейсов:
1. Пользовательский интерфейс UI (user interface) это все, что позволяет человеку общаться с устройством или компьютером, следовательно, это способ сообщить устройству, что мы хотим, чтобы оно делало. Средствами реализации пользовательского интерфейса чаще всего выступают такие инструменты, как: клавиатура компьютерная мышь джойстик дисплей стилус.
2. Графический интерфейс GUI (graphical user interface) или графический интерфейс пользователя. Это система взаимодействия, предоставляющая пользователям доступ к системным объектам и инструментам управления через визуализацию информации – через графические элементы на мониторе. Чаще всего для экранного отображения команд и результатов их выполнения используются окна. Элементы управления программами отображаются визуально внутри окон – в форме: значков иконок кнопок меню списков полей ввода и прочих Управление этими элементами осуществляется с помощью средств реализации, указанных выше – например, с помощью мыши или сенсорного дисплея. Так как различные программы в рамках одной ОС используют идентичные визуальные элементы управления, процесс освоения новых программ для пользователей максимально упрощен. Они учатся на основе ранее полученного опыта. Пример GUI, с которым мы сталкиваемся ежедневно – web-интерфейс. Это любой интернет-браузер, через который мы читаем новости, делаем покупки, смотрим погоду и заказываем пиццу. С его помощью мы взаимодействуем с другими сайтами – программами в интернете. Каждый сайт тоже имеет свой интерфейс, через который система взаимодействует с вами. И это тоже графический web-интерфейс. 
3. Текстовый интерфейс TUI (англ. Text user interface) или текстовый интерфейс пользователя. Это система взаимодействия человека и машины посредством команд и откликов с помощью набора буквенно-цифровых символов – текста.   Лучший пример TUI – командная строка. Это прямой способ диалога с ОС. Он характеризуется низкой требовательностью к ресурсам и высокой скоростью отклика. Имеет немало преимуществ перед GUI в части удобства использования, поэтому алгоритмы с текстовым интерфейсом пишутся и сегодня. Прежде всего, для профессиональных программ и оборудования с низкой производительностью.  Недостаток TUI – ограниченность изобразительных средств. Его могут использовать лишь подготовленные пользователи, имеющие специальные знания. Чтобы команды работали, они должны быть введены точно и без ошибок. Для повышения юзабилити многие профессиональные программы используют интерактивные элементы, за счет которых создают более дружественную среду для работы.  
4. Жестовый интерфейс  Это технология взаимодействия, использующая в качестве средств ввода устройства, которые понимают команды при помощи жестов. Главный мотив реализации такого интерфейса – уход от традиционных компьютерных меню приложений с целью повышения юзабилити и эргономичности управления.   Реализацию таких интерфейсов можно встретить в смартфонах и планшетных ПК с сенсорным экраном, в ноутбуках с тачпадами и прочих устройствах. В них реализована технология считывания координат с нескольких точек – так называемый мультитач (multitouch). Второй пример – жесты мышью/джойстиком, которые алгоритм преобразует в команды. Третий – охранные системы, которые реагируют на движение. Жесты могут считываться в пространстве или на поверхности устройства, с помощью рук или головы, могут совершаться пультом или перчаткой – все это жестовый интерфейс. Он бывает контактным (тактильным) и бесконтактным. Он сложен в реализации, но легок в использовании и интуитивно понятен пользователям.  
5. Голосовой интерфейс  Это средство бесконтактного взаимодействия человека с машиной, где инструментом для ввода выступает микрофон и программа распознавания голосовых сообщений. Раньше это было чем-то из разряда научной фантастики. Сегодня голосовой интерфейс можно встретить в поисковиках, приложениях на смартфонах, мобильных виртуальных помощниках. «Окей, Гугл», «Alexa» от Амазон – все из этой оперы.   Но это хорошие примеры. На самом деле, реализация голосового интерфейса связана с определенными сложностями. Люди не привыкли терпеть «машину, которая не понимает». Поэтому любое устройство или программа с голосовым интерфейсом должна работать безупречно. При реализации этой технологии должны учитываться когнитивная модель целевой аудитории, решаемые задачи, процессы, которые нужно автоматизировать.
6. Интерфейс программ API (англ. application programming interface) или программный интерфейс приложений. Это инструменты взаимодействия компьютерных программ между собой. Функции и структуры программных объектов прописаны специальными алгоритмами. Часто выполнены как отдельная библиотека данных ОС, используются в интернет-протоколах, в описании структур приложений. API описывает абстракцию функциональности программных объектов и по модели реализации является аналогом протокола.    API это некий программный компонент, который помогает разработчикам вставлять вызовы исполняемых кодов одних программ в коды других объектов. Такая технология позволяет взаимодействовать программам, созданным разными разработчиками. Общий стандарт API помогает алгоритмам, написанным на разных языках программирования, обмениваться сообщениями, командами, иными сигналами. Это может происходить как в пределах одного ПК, так и в рамках компьютерной сети.  
7. Интерфейс программ с машинами Взаимодействие между программами и компьютерами, оборудованием и другими машинами реализовано с помощью операционных систем. Они контролируют  работу исполняемых кодов программ и драйверов, передавая команды центральному процессору машин. Например, смартфон. На него установлено множество приложений – мессенджеры, игры, почта, погода и масса других. Все они взаимодействуют с телефоном через операционную систему – Android или iOS. Не было бы операционной системы – приложение не получилось бы установить на гаджет.  
8. Аппаратный интерфейс Взаимодействие машин, компьютеров, оборудования и их компонентов обеспечивает интерфейс аппаратных средств. Он реализован с помощью кабелей, проводов, разъемов, шин и прочих контактных технических портов. Например, основные компьютерные устройства и их компоненты подключаются к ПК через USB.. Это принтеры, устройства ввода, флэшки. Не менее широкое применение находят инструменты бесконтактной коммуникации, такие как Wi-Fi или Bluetooth. Часто их совмещают с контактными. Например, беспроводные компьютерные мыши, принимающий модуль которых подключается через USB.

## 12. Аутентификация и авторизация

Идентификация - процедура, в результате выполнения которой для субъекта идентификации выявляется его идентификатор, однозначно определяющий этого субъекта в информационной системе (логин).

Аутентификация - процедура проверки подлинности, например проверка подлинности пользователя путем сравнения введенного им пароля с паролем, сохраненным в базе данных.

Авторизация - предоставление определенному лицу или группе лиц прав на выполнение определенных действий.

Популярные методы аутентификации:
- Проверка подлинности на основе пароля (Password-based authentication) - это простой метод проверки подлинности, требующий ввода пароля для подтверждения личности пользователя.
- Беспарольная аутентификация (Passwordless authentication) - это когда пользователь проверяется с помощью одноразового ПИН-а (OTP - One-time pins) или magic link, доставленной на зарегистрированный адрес электронной почты или номер телефона;
- Для двухфакторной аутентификации/многофакторной аутентификации (2FA/MFA) требуется более одного уровня безопасности, например дополнительный PIN-код или контрольный вопрос, для идентификации пользователя и предоставления доступа к системе;
- Единый вход (SSO) позволяет пользователям получать доступ к нескольким приложениям с одним набором учетных данных;
- Социальная аутентификация (Social authentication) проверяет и аутентифицирует пользователей с существующими учетными данными на платформах социальных сетей.
- Биометрия (Biometrics) - пользователь предъявляет отпечаток пальца или скан глаза, чтобы получить доступ к системе.

Популярные методы авторизации:
- Управление доступом на основе ролей (RBAC - Role-based access controls) может быть реализовано для управления привилегиями от системы к системе и от пользователя к системе.
- Веб-токен JSON (JWT - JSON web token) - это открытый стандарт для безопасной передачи данных между сторонами, а пользователи авторизуются с помощью пары открытый/закрытый ключ.
- SAML - это стандартный формат единого входа (SSO), в котором аутентификационная информация передается через XML-документы с цифровой подписью.
- Авторизация OpenID проверяет личность пользователя на основе аутентификации сервера авторизации;
- OAuth позволяет API аутентифицировать и получать доступ к запрошенной системе или ресурсу.

## 13. ip-адреса. Идентификация ресурсов в сети. DNS

Вся интернет сеть подразделяется на глобальную (WAN) и локальную (LAN).

Все пользовательские устройства в рамках одной квартиры или офиса или даже здания (компьютеры, смартфоны, принтеры/МФУ, телевизоры и т.д.) подключаются к роутеру, который объединяет их в локальную сеть. Участники одной локальной сети могут обмениваться данными между своими устройствами без подключения к интернет провайдеру. А вот чтобы выйти в сеть (например, выйти в поисковик Яндекс или Google, зайти в VK, Instagram, YouTube или AmoCRM) необходим доступ к глобальной сети.

Каждое устройство в сети имеет свой уникальный IP-адрес. Он нужен для того, чтобы устройства сети понимали куда необходимо направить запрос и ответ. Для выхода в глобальные сети, ваш локальный ip-адрес подменяется роутером на глобальный, который вам выдал провайдер. Локальные ip-адреса - это серые ip-адреса, а глобальные - это белые.

IP-адрес (интернет-протокол) – это идентификатор, позволяющий передавать информацию между устройствами в сети: он содержит информацию о местоположении устройства и обеспечивает его доступность для связи. IP-адреса позволяют различать компьютеры, маршрутизаторы и веб-сайты в интернете и являются важным компонентом работы интернета.

IPv4 (Internet Protocol version 4) используется число из 32 бит, ограничивающие адресное пространство (232 возможными уникальными адресами). Традиционной формой записи IPv4-адреса является запись в виде четырёх десятичных чисел (от 0 до 255), разделенных точками.

IPv6 (Internet Protocol version 6) используется число из 128 бит,  ограничивающие адресное пространство (1028 возможными уникальными адресами). Традиционной формой записи IPv6-адреса является запись в виде 8 групп шестнадцатеричных чисел, разделенных двоеточиями.

Так почему бы просто не перейти на IPv6? Основная причина — стоимость. Для обновления всех серверов, маршрутизаторов и коммутаторов, которые всё это время зависели только от IPv4, требуется уйма денег и времени в таком случае приходит на помощь технология NAT (Network address translation), а точнее её надстройка PAT (Port address translation) - суть заключается в том что много устройств могут выходить в сеть с одним и темже адресом.

Статический IP-адрес (он же постоянный, внешний) – это фиксированный IP-адрес, который назначен провайдером при подключении к интернету на неограниченное время. Главное отличие статического IP-адреса от динамического состоит в том, что динамический IP-адрес может меняться при каждом новом интернет-подключении.

Внутренним (локальным). Так называют адрес, используемый только в пределах одной локальной сети. Внешним (реальным, глобальным). Это уникальный адрес, под которым компьютер виден прочим устройствам в глобальной сети.

Простыми словами о сложном: https://www.youtube.com/watch?v=6tFGoiok0u8

(URI – имя и адрес ресурса в сети, включает в себя URL и URN) = (URL – адрес ресурса в сети, определяет местонахождение и способ обращения к нему) + (URN – имя ресурса в сети, определяет только название ресурса, но не говорит как к нему подключиться)

![image](https://user-images.githubusercontent.com/88891623/187666539-eb2ec85f-a5d4-48cb-8fdc-b2c533dea3c3.png)

Синтаксис URI (Пример: http://www.test.com:80/path/to/myfile.htmlkey1=value1&key2=value2#SomewhereInTheDocument):

1. http:// - это пример протокола (схемы). Тут описывается какой протокол браузер должен использовать. Обычно это HTTP протокол или его безопасная версия - HTTPS. Интернет требует один из этих двух, но браузеры также знают как работать с некоторыми другими, например mailto: (чтобы открыть почтовый клиент) или ftp: для работы с передачей файлов.
2. www.test.com - это доменное имя, идентификатор ответственного за это пространство имён. Идентифицирует, какой именно Веб-сервер получает запрос. Альтернативно, можно просто использовать IP address, но поскольку это не так удобно, то этот способ используется не часто.
3. :80 - это порт сервера. Он идентифицирует технические "ворота", которые нужны для доступа к ресурсу на сервере. Обычно порт не указывается, т.к. существуют общепринятые нормы о стандартных портах для HTTP (80 для HTTP и 443 для HTTPS). В других случаях обязательно нужно указывать.
4. /path/to/myfile.html - это путь к ресурсу на Веб-сервере. Изначально путь типа этого указывал на физическое место файла на сервере, но сейчас всё чаще это псевдоним или описание некоторого абстрактного ресурса.
5. key1=value1&key2=value2 - это дополнительные параметры (query parameters), предоставляемые Веб-серверу. Это список пар "ключ=значение", разделенных символом & . Веб-сервер может использовать эти параметры как дополнительные инструкции, что именно сделать с ресурсом перед отправкой его пользователю. Каждый Веб-сервер имеет свои правила насчет параметров, и единственный надежный способ узнать как конкретный Веб-сервер обрабатывает эти параметры - это спросить того, кто контролирует Веб-сервер.
6. #SomewhereInTheDocument - это "якорь" на другую часть ресурса. Якорь представляет собой что-то вроде "закладки" внутри ресурса, давая браузеру указание показать содержимое с определённого места. В HTML-документе, к примеру, браузер будет скроллить к точке где якорь определён, а на аудио/видео-документе браузер попытается перейти на время, указанное в якоре. Важно что часть, начинающаяся с # - никогда не пересылается серверу в запросе.

DNS (Domain name system) — это система, преобразующая человекочитаемые доменные имена в IP-адреса, понимаемые машиной. Как только нужная DNS-запись найдена, браузер получает IP-адрес, на который посылает запрос. В ответ приходит web-страница.

## 14. Клиент - серверная архитектура. Тонкий и тостый клиент
Клиент-серверная архитектура – это такая архитектура, которая распределяет сетевую нагрузку между сервером и клиентом.

Клиент – локальный компьютер, который выполняет отправку запроса к серверу для возможности выполнения определенных системных действий (привер: браузер).

Сервер – очень мощный компьютер, который предназначается для разрешения определенного круга задач по процессу выполнения программных кодов. Он выполняет работы сервисного обслуживания по клиентским запросам, предоставляет пользователям доступ к определенным системным ресурсам, сохраняет данные или БД.

База данных фактически не является частью веб-сервера, но большинство приложений просто не могут выполнять все возложенные на них функции без нее, так как именно в базе данных хранится вся динамическая информация приложения (учетные, пользовательские данные и пр).

Архитектуру «клиент-сервер» принято разделять на три класса:

Двухзвенная архитектура - распределение трех базовых компонентов между двумя узлами (клиентом и сервером). Двухзвенная архитектура используется в клиент-серверных системах, где сервер отвечает на клиентские запросы напрямую и в полном объеме.

![image](https://user-images.githubusercontent.com/88891623/206902310-ae9bcf81-2dd7-4ea3-89ce-8acdd7c0c60d.png)

Трехзвенная архитектура - сетевое приложение разделено на две и более частей, каждая из которых может выполняться на отдельном компьютере. Выделенные части приложения взаимодействуют друг с другом, обмениваясь сообщениями в заранее согласованном формате.

![image](https://user-images.githubusercontent.com/88891623/206902609-4c4ea0c9-bb4d-4599-ab06-9f0fb162b88c.png)

Трехзвенная архитектура может быть расширена до многозвенной (N-tier, Multi-tier) путем выделения дополнительных серверов, каждый из которых будет представлять собственные сервисы и пользоваться услугами прочих серверов разного уровня.

![image](https://user-images.githubusercontent.com/88891623/206902637-4edeec9f-0ab9-4b7f-ac18-0f8f1ad3ed9e.png)

Двухзвенная архитектура проще, так как все запросы обслуживаются одним сервером, но именно из-за этого она менее надежна и предъявляет повышенные требования к производительности сервера.

Трехзвенная архитектура сложнее, но, благодаря тому, что функции распределены между серверами второго и третьего уровня, эта архитектура предоставляет: Высокую степень гибкости и масштабируемости. Высокую безопасность (т.к. защиту можно определить для каждого сервиса или уровня). Высокую производительность (т.к. задачи распределены между серверами).

Тонкий клиент – это компьютер или программа-клиент в клиент-серверной архитектуре, которая переносит всё или большую часть задач по обработке информации на сервер (пример: браузер используется для работы с веб-приложениями т.к. основная бизнес-логика и мощности расположены на сервере, а клиент просто отправляет запросы на сервер). 

Толстый клиент – это приложение, обеспечивающее расширенную функциональность независимо от центрального сервера. Часто сервер в этом случае является лишь хранилищем данных, а вся работа по обработке и представлению этих данных переносится на машину клиента (пример: 1С бухгалтерия, онлайн игры).

## 15. Эталонные модели OSI и TCP/IP. Виды сетевых протоколов
Стек протоколов TCP/IP (Transmission Control Protocol/Internet Protocol, протокол управления передачей/протокол интернета) — сетевая модель, описывающая процесс передачи цифровых данных. В модели предполагается прохождение информации через четыре уровня.
Уровни TCP/IP:
1. Канальный уровень (link layer) - задача дать описание тому, как происходит обмен информацией на уровне сетевых устройств, определить, как информация будет передаваться от одного устройства к другому. Информация здесь кодируется, делится на пакеты и отправляется по нужному каналу;
2. Межсетевой уровень (internet layer) – задача объединение локальных сетей в глобальную, благодаря чему открывается возможность взаимодействия разных сетей. (IP, ARP, ICMP, IGMP)
3. Транспортный уровень (transport layer) — предназначен для доставки данных. Протоколы TCP и UDP, занимаются доставкой информации:
TCP (протокол управления передачей) — надежный, он обеспечивает передачу информации, проверяя дошла ли она, насколько полным является объем полученной информации и т.д.
UDP (протокол пользовательских датаграмм) — ненадежный, он занимается передачей датаграммы они содержат всю необходимую информацию, чтобы дойти до получателя, но они все равно могут быть потеряны или доставлены в порядке отличном от порядка при отправлении.
Датаграмма — блок информации, передаваемый протоколом через сеть связи без предварительного установления соединения и создания виртуального канала.
4. Прикладной уровень (application layer) - обеспечивает взаимодействие сети и пользователя. Уровень разрешает приложениям пользователя иметь доступ к сетевым службам, таким, как обработчик запросов к базам данных, доступ к файлам, пересылке электронной почты. (HTTP, FTIP, NTP, DHCP и др.)
 
Сетевая модель OSI — посредством данной модели различные сетевые устройства могут взаимодействовать друг с другом. Модель определяет различные уровни взаимодействия систем. Каждый уровень выполняет определённые функции при таком взаимодействии.
Уровни OSI:
1. Физический уровень (physical layer) - отвечает за передачу необработанных битов по каналу связи между физическими устройствами (железом) по проводам (оптоволокно) или без проводов (Bluetooth, Wi-Fi, GSM, 4G и так далее).
2. Канальный уровень (data link layer) - второй уровень решает проблему адресации при передаче информации.
3. Сетевой уровень (network layer) - занимаются построением маршрута от одного устройства к другому с учетом всех потенциальных неполадок в сети.
На сетевом уровне активно используется протокол ARP (Address Resolution Protocol — протокол определения адреса). С помощью него 64-битные MAC-адреса преобразуются в 32-битные IP-адреса и наоборот; (IP, ARP, ICMP, IGMP)
4. Транспортный уровень (transport layer) - предназначен для доставки данных. При этом неважно, какие данные передаются, откуда и куда, то есть, он предоставляет сам механизм передачи.
(TCP, UDP)
5. Cеансовый уровень (session layer) - сеансовый уровень отвечает за поддержку сеанса или сессии связи; (HTTP, HTTPS, FTIP, NTP, DHCP и др.)
6. Представления уровень (presentation layer) - представляет данные (которые все еще являются PDU) в понятном человеку и машине виде. Например, когда одно устройство умеет отображать текст только в кодировке ASCII, а другое только в UTF-8, перевод текста из одной кодировки в другую происходит на шестом уровне. (HTTP, HTTPS, FTIP, NTP, DHCP и др.)
7. Прикладной (application layer) - это то, с чем взаимодействуют пользователи, своего рода графический интерфейс всей модели OSI, с другими он взаимодействует по минимуму. Задача седьмого уровня — использовать свои протоколы, чтобы пользователь увидел данные в понятном ему виде.
Протоколы здесь используют UDP (например, DHCP, FTP) или TCP (например, HTTP, HTTPS, SFTP (Simple FTP), DNS).

Протокол – это набор правил передачи информации. С помощью протоколов мы регламентируем то как наша информация будет передаваться в сети интернета.

Виды сетевых протоколов:
- TCP – обеспечивает надежную доставку сегментов и их упорядочивание, контроль скорости передачи данных, работа с сессиями; 
- IP – протокол, в функции которого входит корректность доставки сообщений по выбранному адресу;
- MAC – вид протокола, на основании которого происходит процесс верификации сетевых устройств. Все устройства, которые подключены к сети Интернет, содержат свой оригинальный MAC-адрес;
- ICMP – протокол, который ответственен за обмен данными, но не используется для процесса передачи информации;
- UDP – протокол, управляющий передачей данных, но данные не проходят верификацию при получении. Этот протокол функционирует быстрее, чем протокол TCP;
- HTTP – протокол для передачи информации (гипертекста), на базе которого функционируют все сегодняшние сайты;
- FTP – протокол передачи информации из особого файлового сервера на ПК конечного пользователя;
- POP3 – классический протокол простого почтового соединения, который ответственен за передачу почты;
- SMTP – вид протокола, который может устанавливать правила для передачи виртуальной почты. Он ответственен за передачу и верификацию доставки, а также оповещения о возможных ошибках;
- SSH - В основном используют для удаленной работы с серверами, а также для надежного переноса большого количества данных. Например, при смене хостинг-провайдера и переносе сайта от одного хостера к другому, для быстрой организации процесса вам понадобится именно SSH доступ к старому хостингу. 

## 16. HTTP-протокол. Методы HTTP
http / https (HyperText Transfer Protocol «протокол передачи гипертекста») – это один и тот же протокол для передачи данных, разница в том что https защищён и на передачу и на получение данных. http работает по порту 80, а https по порту 443.

Структура HTTP-сообщения
Каждое HTTP-сообщение состоит из трёх частей, которые передаются в указанном порядке:
1. Стартовая строка (Starting line) - определяет тип сообщения, различается для запроса и ответа;

2. Заголовки (Headers) - характеризуют тело сообщения, параметры передачи и прочие сведения;

3. Тело сообщения (Message Body) - непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.

Запрос посылает клиент на сервер, а сервер реагирует на запрос и отдаёт свой HTTP response (ответ) Из чего состоят запросы и ответы: 
- HTTP request состоит из: метод, версия протокола, URL (к какому ресурсу мы обращаемся (может не быть)), Host (там где находится наш сервер), Headers (служебная информация может быть, а может и нет);
- HTTP response состоит из: версия протокола, статус код (успешность ответа сервера), status message (статус код имеет текстовую информацию), дата (когда был отправлен ответ от сервера), информация о сервере, Headers (опять же характеризуют нашу основную нагрузку) так-же если ответ содержит в себе какую-то полезную нагрузку, то будет ещё информация с ней (например документ в формате html).

Методы HTTP запроса:
- GET - используется для запроса содержимого указанного ресурса. С помощью метода GET можно также начать какой-либо процесс. В этом случае в тело ответного сообщения следует включить информацию о ходе выполнения процесса. Клиент может передавать параметры выполнения запроса в URI целевого ресурса после символа «?»
- HEAD - аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело. Запрос HEAD обычно применяется для извлечения метаданных, проверки наличия ресурса (валидация URL) и чтобы узнать, не изменился ли он с момента последнего обращения.
- POST - применяется для передачи пользовательских данных заданному ресурсу. С помощью метода POST обычно загружаются файлы на сервер.
- PUT происходит отправка информации на сервер и используется чтобы создавался какой-то объект на сервере. различие методов POST и PUT заключается в понимании предназначений URI ресурсов. Метод POST предполагает, что по указанному URI будет производиться обработка передаваемого клиентом содержимого. Используя PUT, клиент предполагает, что загружаемое содержимое соответствует находящемуся по данному URI ресурсу;
- PATCH - аналогично PUT, но применяется только к фрагменту ресурса.
- DELETE - удаляет указанный ресурс;
- CONNECT - преобразует соединение запроса в TCP/IP-туннель, обычно чтобы содействовать установлению защищённого соединения через нешифрованный прокси.
- OPTIONS - используется для описания параметров соединения с ресурсом.
- TRACE - возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе.

## 17. Socket, WebSocket, AJAX

Сокет (socket - разъем) - название программного интерфейса для обеспечения обмена данными между процессами. Процессы при таком обмене могут исполняться как на одной ЭВМ, так и на различных ЭВМ, связанных между собой сетью. Сокет - абстрактный объект, представляющий конечную точку соединения.

Для взаимодействия между машинами с помощью стека протоколов TCP/IP используются адреса и порты. Адрес представляет собой 32-битную структуру для протокола IPv4, 128-битную для IPv6. Номер порта - целое число в диапазоне от 0 до 65535 (для протокола TCP). Эта пара определяет сокет («гнездо», соответствующее адресу и порту). В процессе обмена, как правило, используется два сокета - сокет отправителя и сокет получателя. Например, при обращении к серверу на HTTP-порт сокет будет выглядеть так: 194.106.118.30:80, а ответ будет поступать на mmm.nnn.ppp.qqq:xxxxx.

WebSocket - протокол связи поверх TCP-соединения, предназначенный для обмена сообщениями между браузером и веб-сервером в режиме реального времени.
В настоящее время в W3C осуществляется стандартизация API Web Sockets. 

WebSocket разработан для воплощения в веб-браузерах и веб-серверах, но он может быть использован для любого клиентского или серверного приложения. Протокол WebSocket - это независимый протокол, основанный на протоколе TCP. Он делает возможным более тесное взаимодействие между браузером и веб-сайтом, способствуя распространению интерактивного содержимого и созданию приложений реального времени.

Разница Socket и WebSocket

Socket и WebSocket - это разные понятия в принципе. При работе по протоколу WebSocket вы будете использовать обычные сокеты для соединения. Так же как и при работе с другими протоколами будут использованы сокеты (и для работы с http, с ftp и др.).

Например, рассмотрим строку вида - ws://127.0.0.1:15000. В ней ws - это именно указание на то, что при обмене данными будет использован протокол WebSocket. 127.0.0.1 - ip адрес компьютера, 15000 - порт, на который производится подключение. Так вот 127.0.0.1:15000 - эта пара, если можно так выразится, и является сокетом.

Протокол WebSocket создавался для того, чтобы можно было поддерживать длительные неразрывные соединения между браузером (который является клиентом) и веб-сайтом (который является сервером).

Разница WebSocket и Socket.IO

Говоря о веб-сокетах, мы имеем ввиду протокол веб-коммуникации, представляющий полнодуплексный канал коммуникации поверх простого TCP-соединения. Проще говоря, эта технология позволяет установить связь между клиентом и сервером с минимальными затратами, позволяя создавать приложения, использующие все преимущества живого общения. Например, представьте, что вы создаете чат: вам необходимо получать и отправлять данные как можно быстрее, верно? С этим прекрасно справляются веб-сокеты! Вы можете открыть TCP-соединение и держать его открытым сколько потребуется. Веб-сокеты используются в следующих случаях:
- Чаты;
- Многопользовательские игры;
- Совместное редактирование;
- Социальные (новостные) ленты;
- Приложения, работающие на основе местоположения.

Socket.IO - библиотека JavaScript, основанная (написанная поверх) на веб-сокетах… и других технологиях. Она использует веб-сокеты, когда они доступны, или такие технологии, как Flash Socket, AJAX Long Polling, AJAX Multipart Stream, когда веб-сокеты недоступны.

Ajax ( Asynchronous Javascript and XML - «асинхронный JavaScript и XML») - подход к построению интерактивных пользовательских интерфейсов веб-приложений, заключающийся в «фоновом» обмене данными браузера с веб-сервером. В результате при обновлении данных веб-страница не перезагружается полностью, и веб-приложения становятся быстрее и удобнее. По-русски иногда произносится транслитом как «аякс». У аббревиатуры AJAX нет устоявшегося аналога на кириллице.

В классической модели веб-приложения:
- Пользователь заходит на веб-страницу и нажимает на какой-нибудь ее элемент;
- Браузер формирует и отправляет запрос серверу;
- В ответ сервер генерирует совершенно новую веб-страницу и отправляет ее браузеру и т. д. , после чего браузер полностью перезагружает всю страницу.

При использовании AJAX:
- Пользователь заходит на веб-страницу и нажимает на какой-нибудь ее элемент;
- JavaScript определяет, какая информация необходима для обновления страницы;
- Браузер отправляет соответствующий запрос на сервер;
- Сервер возвращает только ту часть документа, на которую пришел запрос;
- Скрипт вносит изменения с учетом полученной информации (без полной перезагрузки страницы).

## 18. Веб-сервисы

Веб-сервисы, веб-службы – это веб ориентированная технология которая помогает программам общаться между собой посредством протокола SOAP и архитектурного стиля REST.

SOAP (Simple Object Access Protocol - простой протокол доступа к объектам) - протокол обмена структурированными сообщениями в распределённой вычислительной среде в формате XML.

XML (Xtensible Markup Language — расширяемый язык разметки) – язык разметки документов, позволяющий структурировать информацию разного типа (похож на HTML Разница: HTML заботится об отображении информации, а XML о транспортировке информации).

WSDL (Web services description language) – язык описания веб-сервисов и доступа к ним, основанный на языке XML. Описательный язык основанный на языке разметки XML, и именно в wsdl описан веб-сервис, который вам придется тестировать. WSDL включает в себя информацию о местоположении сервиса, часто включает в себя XSD. Именно из WSDL SOAPUI генерирует проверяемые классы (обязателен для SOAP протокола).

XSD (XML schema definition) - это язык описания структуры XML документа. Его также называют XML Schema. При использовании XML Schema XML парсер может проверить не только правильность синтаксиса XML документа, но также его структуру, модель содержания и типы данных.

Если Вы направите в веб-сервис нестандартный запрос, он ответит на это ошибкой. WSDL - это свод правил общения с вашим сервисом, соблюдая которые вы сможете с этим сервисом коммуницировать. Собственно WSDL и XSD подробно описывают что и в каком виде слать на сервер, чтобы получить хороший ответ.
____
REST (Representational State Transfer – передача состояния представления) - архитектурный стиль взаимодействия компонентов распределённого приложения в сети (с помощью которого описывается структура передачи информации у вебсервисов).

RESTfull – явл. характеристикой наших веб-сервисов т.е. такие веб-сервисы которые отвечают требованиям REST которые предъявляет этот архитектурный стиль (Сам веб-сервис который отвечает требованиям REST).

Вывод: REST описывает структуру нашего веб-сервиса, а RESTfull это уже сам веб-сервис который отвечает требованиям REST.

REST предпочитают использовать всё чаще т.к. этот архитектурный стиль позволяет записывать информацию в более удобном формате который занимает меньше места и повышает производительность нашей системы. Ему предъявляется меньше требований.
 
В REST использует формат JSON (распространённый), но можно использовать и XML и текстовые форматы.

JSON (JavaScript Object Notation) — текстовый формат обмена данными, основанный на JavaScript.

Разница между SOAP и REST веб-сервисами:
1. REST поддерживает различные форматы (JSON (распространённый), но можно использовать и XML и текстовые форматы.). SOAP поддерживает только XML;
2. REST работает только по протоколам HTTP или HTTPS. SOAP в отличие может работать с различными протоколами;
3. SOAP на основе чтения не может быть помещён в кэш в отличии от REST который в таком случае может быть закэширован;
4. REST это архитектурный стиль у которого нету огромного количества правил, которым он должен подчиняться. SOAP это протокол который ограничен теми правилами которые к нему предъявляются;
5. К архитектурному стилю не применяются какие-то жёсткие правила не нужны WSDL (бывает используется формат документа VADL но он не обязателен).
 
Что лучше выбирать на проектах SOAP или REST – тут идёт выбор между простотой или стандартом в случае с REST у вас будет простота, скорость, расширяемость и поддержка многих форматов и нет привязки к тем правилам которые применяются к SOAP.
В случае с SOAP у вас будет больше возможностей по безопасности и так же будет возможность провести тестирование качественно т.к. будет WSDL где будут содержаться образцы наших запросов и не нужно будет обращаться к разработчику, просить его чтобы он предоставил вам информацию и какие-то примеры запросов. Можно сразу брать и тестировать. SOAP так же более ресурсоёмкий, занимает больше места, медленнее и в целом разработка с использованием SOAP дольше. 

gRPC - Для тех, кто еще не слышал о gRPC, gRPC - это не зависящий от языка фреймворк для удаленного вызова процедур (RPC, remote procedure calls), разработанный Google, которая серьезно вкладывается в производительность и масштабирование. Он появился довольно давно, но многие (а, может быть, только я) отложили его на второй план из-за затрат на написание IDL и дополнительного кода стабов (stub), который тоже необходимо поддерживать. В то же время REST очень легко реализуется с помощью ASP.NET Core WebAPI.

Аналогично использованию JSON для REST, для gRPC используется Protocol Buffers - не зависящий от языка формат для сериализации структурированных данных. Этим gRPC отличается от REST. Поддержка Protocol Buffers есть для всех основных языков благодаря компилятору protoc, который генерирует необходимый исходный код классов из определений в proto-файле. Еще важный момент состоит в том, что для связи gRPC использует HTTP/2, а это приносит дополнительные преимущества, такие как сжатие HTTP-заголовков и мультиплексирование запросов.

## 19. Кэш и куки

Куки (cookie - «печенье») - небольшой фрагмент данных, отправленный веб-сервером и хранимый на компьютере пользователя. Веб-клиент (обычно веб-браузер) всякий раз при попытке открыть страницу соответствующего сайта пересылает этот фрагмент данных веб-серверу в составе HTTP-запроса. Применяется для сохранения данных на стороне пользователя, на практике обычно используется для: аутентификации пользователя; хранения персональных предпочтений и настроек пользователя; отслеживания состояния сеанса доступа пользователя; сбора статистики о пользователях.

Cookie легко перехватить и подменить (например, для получения доступа к учетной записи), если пользователь использует нешифрованное соединение с сервером. В группе риска пользователи, выходящие в интернет при помощи публичных точек доступа Wi-Fi и не использующие при этом таких механизмов, как SSL и TLS. Шифрование позволяет также решить и другие проблемы, связанные с безопасностью передаваемых данных.

Большинство современных браузеров позволяет пользователям выбрать - принимать cookie или нет, но их отключение делает невозможной работу с некоторыми сайтами. Кроме того, по законам некоторых стран (например, согласно постановлению Евросоюза от 2016 года, см. общий регламент по защите данных) сайты должны в обязательном порядке запрашивать согласие пользователя перед установкой cookie.

Типы cookie:
- Сессионные cookie - временные cookie, существуют только во временной памяти, пока пользователь находится на странице веб-сайта.
- Постоянные cookie - постоянные cookie-файлы удаляются в определенную дату или через определённый промежуток времени. 
- Сторонние cookie - сторонний файл cookie принадлежит домену, отличному от того, который указан в адресной строке. Этот тип файлов cookie обычно появляется, когда веб-страницы содержат контент с внешних веб-сайтов, например, рекламные баннеры.
- Супер-cookie - это cookie-файл с источником домена верхнего уровня (например, .ru) или общедоступным суффиксом (например, .co.uk). Обычные cookie, напротив, имеют происхождение от конкретного доменного имени, например example.com. Супер-cookie могут быть потенциальной проблемой безопасности и поэтому часто блокируются веб-браузерами. Если браузер разблокирует вредоносный веб-сайт, злоумышленник может установить супер-cookie и потенциально нарушить или выдать себя за законные запросы пользователей на другой веб-сайт, который использует тот же домен верхнего уровня или общедоступный суффикс, что и вредоносный веб-сайт.
- Зомби-cookie - неудаляемые или трудно удаляемые cookie, которые можно восстановить в браузере с помощью JavaScript. Это возможно потому, что для хранения куки сайт одновременно использует все доступные хранилища браузера (HTTP ETag, Session Storage, Local Storage, Indexed DB), в том числе и хранилища приложений, таких как Flash Player (Local Shared Objects), Microsoft Silverlight (Isolated Storage) и Java (Java persistence API).

Кэширование (или кэш) - это некий промежуточный буфер, в котором хранятся данные. Благодаря кэшированию страница сайта не воссоздается заново для каждого пользователя. Кэширование позволяет осуществлять работу с большим количеством данных в максимально сжатые сроки и при ограниченных ресурсах (серверных и пользовательских).

Браузерный кэш позволяет экономить трафик и время, затрачиваемое на загрузку страниц. Но для достижения эффекта экономии, пользователь должен хотя бы один раз посетить нашу страницу, а это означает, что нагрузка на серверные ресурсы уменьшится, но не значительно.

Виды кэширования:
- Браузерное кэширование или клиентское кэширование - Представляет собой составление для браузера команды использовать имеющуюся кэшированную копию. Работа такого кэширования основана на том, что при повторном посещении, браузеру отдаётся заголовок 304 Not Modified, а сама страница или картинка загружаются из локального пользовательского кэша. Получается, что вы экономите на трафике между браузером посетителя и хостингом сайта. Соответственно, страница вашего сайта начинает загружаться быстрее.
- Кэширование файлов и картинок - Браузерное кэширование как нельзя лучше подходит для сайтов, содержащих большое количество изображений: картинка не скачивается каждый раз при открытии сайта, а просто загружается через кэш браузера.
- Кэширование https - Данный вид кэширования считается обязательным для применения, если вы не хотите, чтобы пользователи вашего сайта ждали, когда центр сертификации (а это некий сервер, который отвечает за достоверность вашего сертификата) обработает запрос от браузера пользователя и подтвердит, что ваш сайт действительно подтверждён им.
- Кэширование страниц - Когда страница уже сгенерирована, нужно постоянно отслеживать ее актуальность. Для этого вы должны использовать серверный кэш с отслеживанием времени изменения отдельных частей страницы (если страница строится из множества динамически генерируемых блоков). При таком подходе в каждом ответе от сервера установлены специальные заголовки, обозначающие время изменения страницы, которые затем отправляются браузером пользователя при повторном обращении к странице сайта. Сервер при получении таких заголовков можем проанализировать текущее состояние страницы (возможно, даже отрисовать её), но вместо содержимого страницы отдать заголовок «304 Not Modified», что для пользовательского браузера будет означать, что можно показать страницу из своего (браузера пользователя) кэша.
- Серверное кэширование - Под серверным кэшированием понимаются все виды кэширования, при котором данные хранятся на серверной стороне. Эти данные не доступны клиентским браузерам. Кэш создаётся и хранится по принципу «один ко многим» (многие, в данном случае, — это клиентские устройства).
- Кэширование страницы целиком - отдача страницы происходит практически в момент обращения, как следствие – это возможность обработки миллионов запросов даже на самом слабом сервере со скоростью работы памяти и с незначительным задействованием процессора. Используйте этот кэш, если серверу известны все статичные состояния внешних данных, такие как: uri, get (без дополнительных параметров), пользователь не авторизован — то есть, фактически, это идеальное состояние страницы для гостевых пользователей. Учитывайте тот факт, что при таком кэшировании архитектура сайта или приложения всегда должна однотипно обрабатывать входящие запросы и отдавать однотипные ответы. Такое состояние есть в любом приложении или сайте, его нужно лишь отследить и применить к нему кэш.
- Кэширование результатов компиляции php-файлов - Различают как чистую компиляцию кода, так и его оптимизацию во время компилирования (перевод текста, написанный на языке программирования, в набор машинных кодов).
- Кэширование отдельных блоков страницы - Кэширование отдельных блоков страниц лучше других типов кэширования подойдет, если вам нужно, например, уменьшить количество запросов к базе данных от реальных (авторизованных) пользователей.
- Кэширование php на основе неразделяемых ресурсов - Лучше всего подходит при стандартизации запросов, получении данных из общих ресурсов, наличии внутренних переменных, к которым php-ресурсы обращаются несколько раз при генерации страницы.
- Кэширование php на основе общих ресурсов - Такое кэширование применяйте для хранения сериализированных данных. Например: конфигурационного файла, состояния таблиц, списков файловой системы. 
- Кэширование mysql на основе query cache - это функция MySQL, которая позволяет ускорить извлечение данных из БД. Это делается путем сохранения в памяти операторов SELECT с извлеченными записями; если позже клиент отправляет идентичный запрос, данные выводятся быстрее, поскольку не нужно повторно выполнять команды в БД.
- Кэширование mysql результатов работы, агрегирующие таблицы - Существует правило: обновлений данных должно быть значительно меньше, чем чтения для их отдачи. То есть не имеет смысл агрегировать то, что изменится в тот же момент, при этом важна актуальность агрегированных данных. Что выбирать для агрегирования? Обычно это какая-то статистическая информация о числе записей, дате последнего обновления, авторе последнего обновления и тому подобное.

## 20. Логи и его типы, уровни

Лог — текстовый файл с информацией о действиях программного обеспечения или пользователей, который хранится на компьютере или сервере.

В идеале логи пишутся во время работы всех IT-систем, однако если писать все подряд и «складывать в кучу», полезная информация превратится в хаос. Чтобы упростить поиск и чтение логов, их делят на уровни:
1. Trace — вывод всего подряд. На тот случай, если Debug не позволяет локализовать ошибку. В нем полезно отмечать вызовы разнообразных блокирующих и асинхронных операций.
2. Debug — журналирование моментов вызова «крупных» операций. Старт/остановка потока, запрос пользователя и т.п.
3. Info — разовые операции, которые повторяются крайне редко, но не регулярно. (загрузка конфига, плагина, запуск бэкапа)
4. Warning — неожиданные параметры вызова, странный формат запроса, использование дефолтных значений в замен не корректных. Вообще все, что может свидетельствовать о не штатном использовании.
5. Error — повод для внимания разработчиков. Тут интересно окружение конкретного места ошибки.
6. Fatal — тут и так понятно. Выводим все до чего дотянуться можем, так как дальше приложение работать не будет.

Для удобства обработки логов их делят на типы:
1. системные, связанные с системными событиями,
2. серверные, отвечающие за процесс обращения к серверу,
3. почтовые, работающие с отправлениями,
4. логи баз данных, которые отражают процессы обращения к базам данных,
5. авторизационные и аутентификационные, которые отвечают за процесс входа, выхода из системы, восстановление доступа и пр.

## 21. Коды ответов сервера

- Информационный	100 Continue («продолжай»);
- 101 Switching Protocols («переключение протоколов»);
- 102 Processing («идёт обработка»);
- 103 Early Hints («ранняя метаинформация»).
____
- Успех	200 OK («хорошо»);
- 201 Created («создано»);
- 202 Accepted («принято»);
- 203 Non-Authoritative Information («информация не авторитетна»);
- 204 No Content («нет содержимого»);
- 205 Reset Content («сбросить содержимое»);
- 206 Partial Content («частичное содержимое»);
- 207 Multi-Status («многостатусный»);
- 208 Already Reported («уже сообщалось»);
- 226 IM Used («использовано IM»).
____
- Перенаправление	300 Multiple Choices («множество выборов»);
- 301 Moved Permanently («перемещено навсегда»);
- 302 Moved Temporarily («перемещено временно»), 
- 303 See Other («смотреть другое»)];
- 304 Not Modified («не изменялось»);
- 305 Use Proxy («использовать прокси»);
- 306 — зарезервировано (код использовался только в ранних спецификациях);
- 307 Temporary Redirect («временное перенаправление»);
- 308 Permanent Redirect («постоянное перенаправление»).
____
- Ошибка клиента	400 Bad Request («неправильный, некорректный запрос»);
- 401 Unauthorized («не авторизован (не представился)»);
- 402 Payment Required («необходима оплата»);
- 403 Forbidden («запрещено (не уполномочен)»);
- 404 Not Found («не найдено»);
- 405 Method Not Allowed («метод не поддерживается»);
- 406 Not Acceptable («неприемлемо»);
- 407 Proxy Authentication Required («необходима аутентификация прокси»);
- 408 Request Timeout («истекло время ожидания»);
- 409 Conflict («конфликт»);
- 410 Gone («удалён»);
- 411 Length Required («необходима длина»);
- 412 Precondition Failed («условие ложно»);
- 413 Payload Too Large («полезная нагрузка слишком велика»);
- 414 URI Too Long («URI слишком длинный»);
- 415 Unsupported Media Type («неподдерживаемый тип данных»);
- 416 Range Not Satisfiable («диапазон не достижим»);
- 417 Expectation Failed («ожидание не удалось»);
- 418 I’m a teapot («я — чайник»);
- 419 Authentication Timeout (not in RFC 2616) («обычно ошибка проверки CSRF»);
- 421 Misdirected Request [10];
- 422 Unprocessable Entity («необрабатываемый экземпляр»);
- 423 Locked («заблокировано»);
- 424 Failed Dependency («невыполненная зависимость»);
- 425 Too Early («слишком рано»);
- 426 Upgrade Required («необходимо обновление»);
- 428 Precondition Required («необходимо предусловие»);
- 429 Too Many Requests («слишком много запросов»);
- 431 Request Header Fields Too Large («поля заголовка запроса слишком большие»);
- 449 Retry With («повторить с»);
- 451 Unavailable For Legal Reasons («недоступно по юридическим причинам»).
- 499 Client Closed Request (клиент закрыл соединение)
____
- Ошибка сервера	500 Internal Server Error («внутренняя ошибка сервера»);
- 501 Not Implemented («не реализовано»);
- 502 Bad Gateway («плохой, ошибочный шлюз»);
- 503 Service Unavailable («сервис недоступен»);
- 504 Gateway Timeout («шлюз не отвечает»);
- 505 HTTP Version Not Supported («версия HTTP не поддерживается»);
- 506 Variant Also Negotiates («вариант тоже проводит согласование»);
- 507 Insufficient Storage («переполнение хранилища»);
- 508 Loop Detected («обнаружено бесконечное перенаправление»);
- 509 Bandwidth Limit Exceeded («исчерпана пропускная ширина канала»);
- 510 Not Extended («не расширено»);
- 511 Network Authentication Required («требуется сетевая аутентификация»);
- 520 Unknown Error («неизвестная ошибка»);
- 521 Web Server Is Down («веб-сервер не работает»);
- 522 Connection Timed Out («соединение не отвечает»);
- 523 Origin Is Unreachable («источник недоступен»);
- 524 A Timeout Occurred («время ожидания истекло»);
- 525 SSL Handshake Failed («квитирование SSL не удалось»);
- 526 Invalid SSL Certificate («недействительный сертификат SSL»).

## 22. Типы мобильных приложений. Симуляторы и эмуляторы

Нативные приложения: написаны на родном для определенной платформы языке программирования. Для Android этим языком является Kotlin/Java, тогда как для iOS - objective-С или Swift. Нативные приложения находятся на самом устройстве, доступ к ним можно получить, нажав на иконку. Они устанавливаются через магазин приложений (Play Market на Android, App Store на iOS и др.). Они разработаны специально для конкретной платформы и могут использовать все возможности устройства - камеру, уведомления и т.п. (при наличии разрешений). В зависимости от предназначения нативного приложения, оно может всецело или частично обходиться без наличия интернет-соединения;

Веб-приложения: на самом деле не являются приложениями как таковыми. В сущности, они представляют собой сайты, которые адаптированы и оптимизированы под любой смартфон и выглядят похоже на нативное приложение. И для того, чтобы воспользоваться им, достаточно иметь на устройстве браузер, знать адрес и располагать интернет-соединением. Запуская мобильные веб-приложения, пользователь выполняет все те действия, которые он выполняет при переходе на любой веб-сайт, а также получает возможность «установить» их на свой рабочий стол, создав закладку страницы веб-сайта. Веб-приложения отличаются кроссплатформенностью, то есть способны функционировать, независимо от платформы девайса. Очевидным недостатком такого вида приложений является утрата работоспособности при потере интернет-соединения. Причем из этого выплывает и другой минус - их производительность, которая находится на среднем уровне, в сравнении с другими видами приложений и зависит от возможностей интернет-соединения провайдера услуг. Помимо вышеперечисленного, веб-приложения не могут получить доступ к функциям системы и самого устройства;

Гибридные приложения: это веб-приложение в обертке нативного приложения, что служит контейнером для отображения веб-приложения через встроенный упрощенный браузер (webview в Android(Chrome webview в последней версии) и WKWebView в iOS). Нативный “фундамент” даёт преимущества нативных приложений: доступ к функционалу смартфона (API системы, пуши и т.п.), размещение в маркетах, иконка на рабочем столе и т.п., а сторона веб-приложений дает плюсы в виде кроссплатформенности и простоты обновления контента. Компания, имеющая веб-приложение, может практически “на коленке” собрать гибридные приложения для основных платформ и обеспечить себе присутствие в маркете и на рабочем столе клиентов;

PWA: технология в web-разработке, которая визуально и функционально трансформирует сайт в приложение (мобильное приложение в браузере).
PWA является гибридным решением и позволяет открыть приложение с помощью мобильного браузера. При этом полностью сохраняется функциональность нативного приложения:
- отправка push-уведомлений (кроме устройств под управлением iOS);
- работа в режиме офлайн;
- доступ к аппаратному обеспечению устройства (с ограничениями);
- установка ярлыка (иконки) на рабочий стол мобильного устройства, визуально не отличающегося от ярлыка нативного приложения, и пр.

Эмулятор: пытается дублировать устройство - это полноценная виртуалка (контейнер) со своей сетевой картой и диском, то есть представляет собой полную повторную реализацию конкретного устройства или платформы изолированно внутри нашей хост-системы. Одним из недостатков такого подхода является скорость работы. Примером служит эмулятор в Android Studio, хотя можно найти и неофициальные эмуляторы и образы Android-устройств.

Симулятор: пытается дублировать только поведение устройства. Как правило, симулятор - это имитация лишь отдельных свойств, возможностей или функций симулируемой системы, причем не в полном объеме, а только в том, в каком это необходимо в рамках тех задач, которые были поставлены перед симулятором. Вы как будто бы работаете с настоящим устройством, но при этом под капотом оно является лишь ПО-имитацией, не работающей изолированно от нашей системы и использующей общий диск и сеть. Примером служит симулятор в XCode.

## 23. Основные проверки при тестировании мобильного приложения

Функциональное тестирование: В данном пункте нам важно убедиться, что наш продукт соответствует нужной функциональной спецификации, упомянутой в документации по разработке.
- Установка/удаление/накатка версий;
- Запуск приложения (отображение Splash Screen);
- Работоспособность основного функционала приложения:
    - Авторизация (по номеру телефона/через соц. сети/e-mail);
    - Регистрация (по номеру телефона/через соц. сети/e-mail);
    - Онбординг новых пользователей;
    - Валидация обязательных полей;
    - Навигация между разделами приложения;
    - Редактирование данных в профиле пользователя;
    - Проверка оплаты;
    - Тестирование фильтров;
    - Бонусы;
- Корректное отображение ошибок;
- Работа с файлами (отправка/получение/просмотр);
- Тестирование тайм-аутов;
- Тестирование заглушек (не соединения с интернетом/нет, например, товаров и т.д);
- Тестирование pop-up, алертов;
- Тестирование WebView (WebView – это системный компонент, которое отвечает за открытие веб-страниц в рамках других приложений. Нажатие на ссылку приводит к тому, что она открывается в интерфейсе самого приложения, вместо того чтобы перенести вас в браузер. Таким образом разработчику проще отслеживать ваши действия, поскольку получить их из стороннего браузера у него не выйдет);
- Скролл/свайп элементов;
- Тестирование PUSH уведомлений;
- Сворачивание/разворачивание приложения;
- Разные типы подключений (сотовая связь/Wi-Fi);
- Ориентация экрана (альбомная/портретная);
- Темная/светлая темы;
- Реклама в приложении;
- Шаринг контента в соц. сети;
- Работа приложения в фоне;
- Пагинация страниц;
- Политики конфиденциальности и прочие ссылки на документы.

Тестирование совместимости: Тестирование совместимости используется, чтобы убедиться, что ваше приложение совместимо с другими версиями ОС, различными оболочками и сторонними сервисами, а также аппаратным обеспечением устройства.
- Корректное отображение гео;
- Информации об операциях (чеки и т.д.);
- Различные способы оплаты (Google Pay, Apple Pay);
- Тестирование датчиков (освещенности, температуры устройства, акселерометр и т.д.);
- Тестирование прерываний (входящий звонок/смс/push/будильник/режим «Не беспокоить» и т.д.);
- Подключение внешних устройств (карта памяти/наушники и т.д.).

Тестирование безопасности: Данная проверка нацелена на поиск недостатков и пробелов с точки зрения безопасности приложения.
- Тестирование разрешений (доступ к камере/микрофону/галерее/и т.д.);
- Данные пользователя (пароли) не передаются в открытом виде;
- В полях, с вводом пароля и подтверждением пароля, данные скрываются астерисками.

Тестирование локализации и глобализации: Тестирование интернационализации/глобализации приложения включает тестирование приложения для различных местоположений, форматов дат, чисел и валют, а также замену фактических строк псевдостроками. Тестирование локализации включает тестирование приложения с локализованными строками, изображениями и рабочими процессами для определенного региона.
- Все элементы в приложении переведены на соответствующий язык;
- Тексты зашиты внутри приложения и пользователь в настройках приложения может выставить необходимый язык;
- Тексты зависят от языка в системных настройках;
- Тексты приходят с сервера;
- Корректное отображение форматов дат (ГОД - МЕСЯЦ - ДЕНЬ или ДЕНЬ - МЕСЯЦ - ГОД.);
- Корректное отображение времени в зависимости от часового пояса.

Тестирование удобства использования помогает удостовериться в простоте и эффективности использования продукта пользователем, с целью достижения поставленных целей. Иными словами, это не что иное, как тестирование дружелюбности приложения для пользователя.
- Корректное отображение элементов на устройствах с различными разрешениями экранов;
- Все шрифты соответствуют требованиям;
- Все тексты правильно выровнены;
- Все сообщения об ошибках верные, без орфографических и грамматических ошибок;
- Корректные заголовки экранов;
- В поисковых строках присутствуют плейсхолдеры (Плейсхолдеры — в интернет-маркетинге: указатель места заполнения или подсказка, расположенная внутри каждого поля подписной формы);
- Неактивные элементы отображаются серым;
- Ссылки на документы ведут на соответствующий раздел на сайте;
- Анимация между переходами;
- Корректный возврат на предыдущий экран;
- Поддерживаются основные жесты при работе с сенсорными экранами (swipe back и т.д.).

Стрессовое тестирование: Стрессовое тестирование направлено на определение эффективности производительности приложения в условиях повышенной нагрузки. Стресс-тест в этом контексте ориентирован только на мобильные устройства.
- Высокая загрузка центрального процессора;
- Нехватка памяти;
- Загрузка батареи;
- Отказы;
- Низкая пропускная способность сети;
- Большое количество взаимодействий пользователя с приложением (для этого может понадобиться имитация реальных условий состояния сети).

Кросс-платформенное тестирование: Важный вид тестирования, который необходимо проводить для понимания того, будет ли должным образом отображаться тестируемый продукт на различных платформах, используемых целевой аудиторией.
- Работоспособность приложения на различных устройствах разных производителей

Тестирование производительности: Если пользователь устанавливает приложение, и оно не отображается достаточно быстро (например, в течение трех секунд), оно может быть удалено в пользу другого приложения. Аспекты потребления времени и ресурсов являются важными факторами успеха для приложения, и для измерения этих аспектов проводится тестирование производительности.
- Время загрузки приложения;
- Обработка запросов;
- Кэширование данных;
- Потребление ресурсов приложением (например расход заряда батареи).

## 24. Гайдлайны (11 примеров). Особенности мобильного тестирование

Гайдлайны (требования к дизайну):
1. Системный шрифт: iOS = шрифт San Francisco; Android = шрифт Roboto.
2. Единицы измерения: iOS = Point (1 pt = 1 pixel); Android = Density-independent (1 dp = 1 pixel на экране с плотностью MDPI).
3. Размер экрана: iOS = 320pt х 568pt. (Обычно проектируют приложение под наименьший размер — iPhone 5 SE. Делаю это, чтобы избежать некорректного отображения контента на маленьких экранах); Android = 360dp х 640dp. (Самая популярная и удобная на сегодняшний день).
4. Тени в интерфейсе: iOS = (В iOS принципиально нет теней); Android = (Тени играют большую роль. Они добавляют интерфейсу третье пространство (ось z)).
5. Дизайн: iOS = Human Interface Guidelines (HIG) это про плоский, легкий, дружелюбный дизайн; Android = Material Design имеет несколько основополагающих принципов: смелый, графический, сознательный; осмысленная анимация; гибкая основа и кроссплатформенность.
6. Физическое взаимодействие с телефоном: iOS = кнопка «Home»; Android = Android Navigation Bar Он либо физически встроен в смартфон, либо является частью интерфейса.
7. Верхнеуровневая навигация (приложений): iOS = tab Bar (находится внизу экрана); Android = Bottom Navigation Bar (находится внизу экрана) и Tabs (вкладки верхнеуровневой навигации).
8. Дополнительная навигация (приложений): iOS = More (пункт навигации который не помещается в нижней панели вкладок, могут быть переведены на общую вкладку «ещё»); Android = Navigation Drawer (дополнительная навигация расположена в боковом меню).
9. Навигация в верхней части экрана: iOS = Navigation Bar (Всегда слева в верху есть кнопка назад; Присутствует заголовок (сжимается при прокрутке страницы по центру)); Android = Top App Bar (Заголовок смещён к левому краю; Слева располагается кнопка «гамбургер» в последующем стрелка назад).
10. Поиск: iOS = Search Bar (Чтобы отменить поиск у iOS нужно нажать кнопку «отмена»); Android = Search (Чтобы отменить поиск у Android нужно нажать кнопку назад «стрелка»).
11. Основные кнопки призыва к действию: iOS = Button (В основном это кнопка «+» справа вверху; В некоторых приложениях кнопка «блокнот и ручка»); Android = Floating action button (FAB) (В основном кнопка «+» в правом нижнем углу экрана; В некоторых приложениях может отображаться в верхней части экрана).

Особенности мобильного тестирование:

Размер экрана и touch-интерфейс:
1. удобный размер кнопок, чтобы не надо было искать ее на экране и попадать с третьего раза по ней;
2. скорость отклика элементов (высокая; нажатая клавиша должна визуально отличаться).

Утечки памяти:
1. можно проверить с помощью программы Instruments (стандартное приложение MacOS). Может быть не более 30мб на 2г айфон/айпод, примерно 70мб для всех девайсов до 2-го айпада;
2. уделить внимание окнам с большим количеством информации, при длительном пребывании пользователя в приложении.

Проверка работы приложений на ретина экранах и различных версия OS:
1. корректное отображение различных элементов на экранах ретина/не ретина;
2. установка приложения на корректную версию OS;
3. проверить установку на все возможные девайсы;
4. различные функции на девайсах: отсутствие/наличие камеры(ipad) (автофокуса), отсутствие/наличие GPS.

Проверка типа покупок (восстанавливаемые, не восстанавливаемые):
1. проверка соответствия фактической/заявленной стоимости приложения;
2. проверка восстановления покупки независимо от девайса, а с привязкой к учетной записи.

Проверка работы обратной связи:
1. сообщения при загрузке контента/прогресс;
2. сообщения при ошибке доступа к сети;
3. наличие сообщений при попытке удалить важную информацию;
4. наличие экрана/сообщения при окончании процесса/игры (экран Game over).

Проверка работы обновлений:
1. проверка различных путей установки обновлений (wifi, bluetooth, usb);
2. проверка работы установленных изменений, мест, куда они вносились;
3. убедиться в поддерживаемости обновлений более старыми операционками, чтобы элементы которые на новой системе работают хорошо не падали на более старых версиях.

Проверка реакции приложения на внешние прерывания:
1. входящие/исходящие смс, ммс, звонки;
2. разряд/изъятие батареи;
3. отключение сети/wifi;
4. подключение кабеля, карты,зарядки.

Реклама в мобильном приложении:
1. реклама не должна перекрывать кнопки управления приложением;
2. реклама должна иметь доступную кнопку закрытия, потому что чаще всего пользователь ее не ищет, а просто удаляет приложение с концами.

Проверка локализации:
1. на другом языке на экране должно хватить места для текста;
2. даты должны соответствовать формату установленного региона;
3. временные настройки должны быть соблюдены.

Проверка энергопотребления:
1. необходимо проверять насколько сильно ваше мощное приложение опустошает батарею устройства. Скорее всего пользователь удалит его, если из-за него мобилку придется под заряжать слишком часто.

Вопросы и ответы по теме:
- Какой кейс для установки не валидный для iphone? Ответ: установка на cd карту.
- Почему Apple может сделать reject (отклонить) приложения из appstore или не пропустить на релиз? Ответ: Все правила прописаны в ios review guidelines. Должно соответствовать приложение этому документу. 
- В каких состояниях может находится приложение? Ответ: 1. Выключено; 2. Запущено; 3. Работать в фоне.
- Необходимо собрать приложение на Android какие варианты? Ответ: 1. передать на телефон файл apk и инсталлировать. 2. Android Studio и запустить на живом девайсе. 3. Android Debug Bridge (ADB)
- Какие тесты реконектов есть в мобилках? Ответ: 1. Обрыв связи; 2. Переход с 2G в 3G в 4G и наоборот; WiFi на мобильную и наоборот; Звонок в 2G (он не поддерживает 2-ух стороннюю связь); Переход в режим полёта.

## 25. Основы HTML и CSS

HTML (Hyper Text Markup Language) — это язык гипертекстовой разметки страницы. Он используется для того, чтобы дать браузеру понять, как нужно отображать загруженный сайт.

CSS (Cascading Style Sheets «каскадные таблицы стилей») — формальный язык описания внешнего вида документа (веб-страницы), написанного с использованием языка разметки (чаще всего HTML или XHTML). Также может применяться к любым XML-документам, например, к SVG или XUL.

Введение в HTML: http://htmlbook.ru/samhtml/vvedenie-v-html
```
Базовые теги:
- <!--...--> — тег для добавления комментариев в документ. Помещённые внутри него теги не интерпретируются браузером.
- <!DOCTYPE> — показывает браузеру тип документа, сообщает его версию и язык.
- <html></html> — корневой тег, который сообщает браузеру, что это HTML-документ. Все остальные элементы помещаются внутри него.
- <head></head>— контейнер, в который помещаются метаданные документа, не видимые пользователям, но считываемые поисковыми роботами: например, <title> или <style>.
- <meta> — тег для оформления метаданных документа, используемых браузером для обработки страницы, а поисковиками — для индексации.
- <body></body> — тег, обрамляющий видимую пользователям часть документа. Всё, что вы укажите внутри этого контейнера, отобразится на странице. Тег <body> имеет несколько атрибутов, позволяющих управлять цветами.
- <body bgcolor=?> — цвет фона документа в формате RGB.
- <body text=?> — цвет текста.
- <body link=?> — цвет гиперссылок.
- <body vlink=?> — цвет гиперссылок, по которым уже переходили.
- <body alink=?> — цвет гиперссылок при нажатии.
- <title></title>— метатег, который задаёт название страницы, отображаемое на вкладке браузера.
- <header></header> — определяет содержимое блока с вводной информацией сайта или группой ссылок.

Форматирование текста:
- <h1></h1>......<h6></h6>. — теги заголовков, от самого большого к самому маленькому.
- <b></b> — жирный текст без придания важности выделенному фрагменту.
- <strong></strong> — расставление акцентов в тексте путём выделения его фрагментов полужирным начертанием.
- <i></i> — выделение текста курсивом без придания важности.
- <del></del> — зачёркивает текст, помечая его удалённым.
- <s></s> — отображает перечёркнутый текст.
- <ins></ins> — подчёркивает текст, визуально выделяя внесённые изменения.
- <u> — подчёркивание без дополнительного акцентирования внимания.
- <em></em> — расставление акцентов путём выделения фрагментов текста курсивом.
- <mark></mark> — выделение частей текста жёлтым маркером.
- <tt></tt> — имитация текста, набранного на печатной машинке.
- <small></small> — отображение фрагмента с меньшим кеглем шрифта, чем у остального текста.
- <sub></sub> — подстрочное начертание символов.
- <sup></sup> — надстрочное начертание символов.
- <cite></cite> — оформление цитат.
- <address> — добавление контактов или подписи автора. При открытии в вею-браузере выделяется курсивом.
- <pre></pre> — вывод неформатированного текста с сохранением пробелов и особенностей переносов.
- <p></p> — контейнер для абзаца.
- <br> — переносит текст на другую строку без создания абзаца.
- <blockquote> </blockquote> — отступы с обеих сторон для оформления цитаты или врезки.
- <q></q> — краткое цитирование.
- <dl></dl> — контейнер для размещения термина и его определения.
- <dt> — добавление термина.
- <dd> — добавление определения понятия
- <dfn> — выделение термина курсивом. Последующий текст должен раскрывать понятие.
- <abbr> — указывает, что текст является аббревиатурой или акронимом. Для добавления пояснения используется атрибут title.
- <ol></ol> — список с цифрами.
- <ul></ul> — список со значками.
- <li> — отметка каждого элемента перечня (цифра или значок в зависимости от типа списка).
- <a></a> — добавление гиперссылки в текст. Имеет обязательный атрибут href, в котором указывается ссылка или якорь. Внутри контейнера помещается текст, при нажатии на который происходит переход на другую страницу или другое место на этой же странице.
- <code></code> — выделение фрагмента кода с помощью шрифта monospace. 

Встраивание элементов:
- <img></img> — вставка изображения. Имеет атрибут src, который указывает на адрес нужного файла. Есть и другие атрибуты:
- <img src="name" align=?> — выравнивание к одной из сторон документа. Например, значение right переместит рисунок в правый край, а left — в левый.
- <img src="name" border=?> — позволяет настроить в пикселях толщину рамки вокруг изображения.
- <picture></picture> — контейнер для расположения элемента <img> без <source>, который даёт браузеру возможность самостоятельно выбрать подходящую картинку.
- <audio></audio>  — вставка звукового контента.
- <video></video> — вставка видео (поддерживается Ogg, WebM и MP4).
- <source></source> — указывает местоположение файла для <video>, <audio> и <picture>
- <track> — формирует субтитры для <video> и <audio>.
- <object></object> — контейнер, через который встраиваются мультимедийные файлы. Для передачи параметров применяется тег <param>.
- <hr> — размещает на странице горизонтальную линию. Имеет несколько атрибутов.
- <hr size=?> — устанавливает высоту линии.
- <hr width=?> — устанавливает ширину линии.
- <hr noshade> — убирает тень у линии.
- <hr color=?> — задаёт цвет линии.
- <script></script> — определяет выполнение сценария на стороне посетителя сайта. Может содержать сам скрипт или иметь ссылку на  внешний источник.
- <noscript></noscript> — ограничивает фрагмент документа, в котором скрипт не выполняется.

Работа с таблицами:
- <table></table> — размещает таблицу. Все остальные теги для форматирования таблиц должны находиться внутри это контейнера.
- <thead></thead> — определяет заголовок.
- <tbody></tbody> — отмечает тело таблицы.
- <td></td> — создаёт одну ячейку.
- <th></th> — указывает на заголовок ячейки.
- <tr> — создание одной строки.  
- <tfoot></tfoot> — показывает нижний колонтитул.
- <caption></caption> — вставляет подпись. Указывается после тега <table>.
- <col> — позволяет указать ширину и другие параметры одной или нескольких колонок.

Создание форм и кнопок:
- <form></form> — создание форм на странице. С помощью HTML описывается только внешний вид, для выполнения функций требуется запуск соответствующих скриптов на сервере.
- <button></button> — создаёт интерактивную кнопку. Внутри контейнера нужно поместить текст или изображение.
- <select multiple name="NAME" size=?></select> — формирует меню с поддержкой скроллинга.
- <select name="NAME"></select> — создаёт ниспадающее меню.
- <option></option> — описывает каждый отдельный пункт меню.
- <input> — формирует поля для добавления пользовательских данных.
- <output> — выводит результаты вычислений, сделанных с помощью скрипта.
- <label> — оформляет пометку для поля, созданного тегом <input>.
- <textarea></textarea> — создаёт большие поля для ввода текста.
```

## 26. HTML DOM

DOM – это объектное представление исходного HTML-кода документа. Процесс формирования DOM происходит так: браузер получает HTML-код, парсит его и строит DOM.

Когда браузер загружает HTML-код страницы, он строит на основании него объектную модель документа (Document Object Model или сокращённо DOM).

Почему не использовать в этом случае просто HTML? Потому что HTML – это текст, и с ним невозможно работать так как есть. Для этого нужно его разобрать и создать на его основе объект, что и делает браузер. И этим объектом является DOM.

Основные этапы работ, которые выполняет браузер для преобразования исходного кода HTML-документа в отображение стилизованной и интерактивной картинки на экране. Процесс называется Critical Rendering Path (CRP).

![image](https://user-images.githubusercontent.com/88891623/189880355-8418d1db-9121-4069-9994-b316c4c0f45f.png)

Шаги:
- Анализирует HTML-документ, чтобы определить то, что в конечном итоге нужно отобразить на странице;
- Выполняет отрисовку того что нужно отобразить.

Результатом первого этапа является формирование дерева рендеринга (render tree). Данное дерево содержит видимые элементы и текст, которые нужно отобразить на странице, и также связанные с ними стили. Это дерево дублирует структуру DOM, но включает как мы отметили выше только видимые элементы. В render tree каждый элемент содержит соответствующий ему объект DOM и рассчитанные для него стили. Таким образом, render tree описывает визуальное представление DOM.

Чтобы построить дерево рендеринга, браузеру нужны две вещи:
- DOM, который он формирует из полученного HTML-кода;
- CSSOM (CSS Object Model), который он строит из загруженных и распознанных стилей.

На втором этапе браузер выполняет отрисовку render tree. Для этого он:
- рассчитывает положение и размеры каждого элемента в render tree, этот шаг называется Layout;
- выполняет рисование, этот шаг называется Paint.

После Paint все нарисованные элементы находятся на одном слое. Для повышения производительности страницы браузер выполняет ещё один шаг, который называется Composite. В нем он группирует элементы по композиционным слоям. Именно благодаря этому этапу мы можем создать на странице плавную анимацию элементов при использовании таких свойств как transform, opacity. Так как изменение этих свойств вызовет только одну задачу Composite.

Layout и Paint – это ресурсоемкие процессы, поэтому для хорошей отзывчивости вашей страницы или веб-приложения, необходимо свести к минимуму операции которые их вызывают.
- Список свойств, изменение которых вызывают Paint: color; background; visibility; border-style и другие.
- Список свойств, изменение которых вызывает Layout: width и height; padding и margin; display; border; top, left, right и bottom; position; font-size и другие.
